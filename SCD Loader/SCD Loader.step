{"type":"code","name":"SCD Loader.step","displayName":"SCD Loader.step","description":"","templates":{"SAS":"/*==========================================================================* \n * Custom Step:     SCD loader                                              * \n * Transform:       SCD loader                                              * \n * Description:     This macro loads a target table and captures Type 2 as  *\n *                  as well as Type 1 changes.                              *           \n *==========================================================================*/\n%let BEGINDATE=&BEGINDATE_NAME;\n%let ENDDATE=&ENDDATE_NAME;\n%let GENERATEDKEY=&GENERATEDKEY_NAME;\n%let CURRENTIND=&CURRENTIND_NAME;\n\n%macro scdloader( begindate=\n\t\t\t,enddate=\n\t\t\t,etls_begdate=\n\t\t\t,etls_enddate=\n\t\t\t,businesskey=\n\t\t\t,generatedkey=\n\t\t\t,currentind=\n\t\t\t,detectchanges=\n\t\t\t,type1changes=\n\t\t\t,input_table1=\n\t\t\t,output_table1=\n\t\t\t,closeout=No\n\t\t\t,loopcol=\n\t\t\t,loopval=\n\t\t\t);\n\t%if (%sysfunc(exist(&output_table1.)) eq 0) %then %do;\n\n\t\tproc sql;\n\t\t\t%if %length(&loopcol.) = 0 %then %do;\n\t\t\t\tcreate table &output_table1. as\n\t\t\t%end;\n\t\t\t%else %do;\n\t\t\t\tcreate table &output_table1. (drop=&loopcol.)as\n\t\t\t%end;\n\n\t\t\tselect\n\t\t\t\t. as &generatedkey. length = 8,\n\t\t\t\t*,\n\t\t\t\t. as &begindate. length = 8\n\t\t\t\tformat = Datetime20.,\n\t\t\t\t. as &enddate. length = 8\n\t\t\t\tformat = Datetime20.,\n\t\t\t\t\"\" as &currentind. length = 1\n\t\t\tfrom &input_table1. (obs=0)\n\t\t\t;\n\t\tquit;\n\n\t%end;\n\n\t/*---- Temporary cross reference table being used  ----*/\n\t/* Delete any existing temporary cross-reference table  */\n\tproc datasets lib = work nolist nowarn memtype = (data view);\n\t\tdelete etls_sortedxref;\n\tquit;\n\n\t/* Sort target table records before creating the temporary cross reference  */\n\t/*  table:                                                                  */\n\tproc sort data = &output_table1(where = (&currentind. = 'Y'))\n\t\tout = work.etls_sortedxref(keep=&generatedkey. &businesskey. &begindate. &enddate. &currentind. &detectchanges.);\n\t\tby &businesskey.;\n\trun;\n\n\t%let etls_str = '\"' ||KTRIM(KLEFT(%sysfunc(tranwrd(%quote(&detectchanges),%str( ),%str(%)%) || KTRIM%(KLEFT%())))) || '\"';\n\n\t%if %length(&type1changes.) = 0 %then %do;\n\n\t\t/* Generate change digest (v1.1)  */\n\t\tdata work.etls_sortedxref(keep = &generatedkey. &businesskey. &begindate. &enddate. DIGEST_VALUE);\n\t\t\tlength etls_md5 $16.;\n\t\t\tlength DIGEST_VALUE $32.;\n\t\t\tset work.etls_sortedxref;\n\t\t\tby &businesskey.;\n\t\t\tetls_str = &etls_str;\n\t\t\tetls_md5 = md5(etls_str);\n\t\t\tDIGEST_VALUE = put(etls_md5, hex32.);\n\t\trun;\n\n\t%end;\n\t%else %do;\n\t\t%let etls_str_type1 = '\"' ||KTRIM(KLEFT(%sysfunc(tranwrd(%quote(&type1changes),%str( ),%nrstr(%)%) || ' ' || KTRIM%(KLEFT%())))) || '\"';\n\n\t\t/* Generate change digest (v1.1)  */\n\t\tdata work.etls_sortedxref(keep = &generatedkey. &businesskey. &begindate. &enddate. DIGEST_VALUE DIGEST_VALUE_TYPE1);\n\t\t\tlength etls_md5 $16.;\n\t\t\tlength DIGEST_VALUE $32.;\n\t\t\tlength DIGEST_VALUE_TYPE1 $32.;\n\t\t\tset work.etls_sortedxref;\n\t\t\tby &businesskey.;\n\t\t\tetls_str = &etls_str.;\n\t\t\tetls_md5 = md5(etls_str);\n\t\t\tDIGEST_VALUE = put(etls_md5, hex32.);\n\t\t\tetls_str_type1 = &etls_str_type1.;\n\t\t\tetls_md5 = md5(etls_str_type1);\n\t\t\tDIGEST_VALUE_TYPE1 = put(etls_md5, $hex32.);\n\t\trun;\n\n\t%end;\n\n\tproc sql;\n\t\t%if %length(&loopcol.) = 0 %then %do;\n\t\t\tcreate table work.temp0 as\n\t\t%end;\n\t\t%else %do;\n\t\t\tcreate table work.temp0 (drop=&loopcol.) as\n\t\t%end;\n\n\t\tselect\n\t\t\t. as &generatedkey. length = 8,\n\t\t\t*,\n\t\t\t. as &begindate. length = 8\n\t\t\tformat = Datetime20.,\n\t\t\t. as &enddate. length = 8\n\t\t\tformat = Datetime20.,\n\t\t\t\"\" as &currentind. length = 1\n\t\tfrom &input_table1.\n\t\t\t%if %length(&loopcol.) > 0 %then\n\n\t\t\t%do;\n\t\t\t\twhere &loopcol. = &loopval.\n\t\t\t%end;\n\t\t;\n\tquit;\n\n\t%let SYSLAST = work.temp0;\n\t%let etls_lastTable = &SYSLAST;\n\t%let etls_tableOptions =;\n\n\t%if %length(&type1changes.) = 0 %then %do;\n\n\t\t/* Generate change digest (v1.1)  */\n\t\tdata work.etls_source(drop=etls_str etls_md5 compress=no);\n\t\t\tset &syslast;\n\t\t\tlength etls_md5 $16.;\n\t\t\tlength DIGEST_VALUE $32.;\n\t\t\tetls_str = &etls_str.;\n\t\t\tetls_md5 = MD5(etls_str);\n\t\t\tDIGEST_VALUE=put(etls_md5, hex32.);\n\t\trun;\n\n\t%end;\n\t%else %do;\n\n\t\t/* Generate change digest (v1.1)  */\n\t\tdata work.etls_source(drop=etls_str etls_md5  etls_str_type1 compress=no);\n\t\t\tset &syslast;\n\t\t\tlength etls_md5 $16.;\n\t\t\tlength DIGEST_VALUE $32.;\n\t\t\tlength DIGEST_VALUE_TYPE1 $32.;\n\t\t\tetls_str = &etls_str.;\n\t\t\tetls_md5 = MD5(etls_str);\n\t\t\tDIGEST_VALUE=put(etls_md5, hex32.);\n\t\t\tetls_str_type1 = &etls_str_type1.;\n\t\t\tetls_md5 = MD5(etls_str_type1);\n\t\t\tDIGEST_VALUE_TYPE1 =put(etls_md5, $hex32.);\n\t\trun;\n\n\t%end;\n\n\t/* Generate the from date expression  */\n\t%let etls_begdate = &etls_begdate;\n\n\t/* Generate the default to date expression  */\n\t%let etls_enddate = &etls_enddate;\n\n\t/* Sort the source table by business key and beginning/from date columns.  */\n\tproc sort data=work.etls_source out=work.etls_source(compress=no);\n\t\tby &businesskey. &begindate.;\n\trun;\n\n\t%let last_word = %scan(&businesskey,-1,%str( ));\n\n\t/*---- Set beginning dates and close out any history records   ----*/\n\tdata work.etls_source (drop = etls_sameday etls_cnt etls_closedate);\n\t\tset work.etls_source;\n\t\tby &businesskey.;\n\n\t\t/* Set beginning dates if null  */\n\t\tif &begindate. eq . then\n\t\t\t&begindate. = &etls_begdate.;\n\n\t\tif first.&last_word. then\n\t\t\tetls_cnt = 0;\n\t\telse etls_cnt + 1;\n\n\t\t/* Close out any history records if they exist  */\n\t\tif not last.&last_word. then do;\n\t\t\tobsnum = _n_ + 1;\n\t\t\tset work.etls_source(keep = &begindate.\n\t\t\t\trename = (&begindate. = etls_closedate))\n\t\t\t\tpoint = obsnum;\n\n\t\t\tif etls_closedate eq . then\n\t\t\t\tetls_closedate = &etls_begdate;\n\n\t\t\tif &begindate. eq etls_closedate then\n\t\t\t\tetls_closedate = etls_closedate + (etls_cnt + 1);\n\n\t\t\tif &enddate. eq . then\n\t\t\t\t&enddate. = etls_closedate - 1;\n\t\tend;\n\n\t\t/* Fix the beginning dates if needed  */\n\t\tetls_sameday = lag1(&begindate.);\n\n\t\tif not first.&last_word. and etls_sameday eq &begindate. then\n\t\t\t&begindate. = &begindate. + etls_cnt;\n\trun;\n\n\t/*---- Generate the maximum generated key  ----*/\n\t/* Calculate the max generated key value and hold the value in the macro  */\n\t/*  variable &etls_maxkey                                                 */\n\t%let etls_maxkey = -1;\n\n\tproc sql noprint;\n\t\tselect compress(put(max(&generatedkey.), best32.))\n\t\t\tinto :etls_maxkey\n\t\t\t\tfrom &output_table1.;\n\tquit;\n\n\t/* If \"etls_maxkey\" does not have a value, then set it to zero.  */\n\t%if (&etls_maxkey eq .) %then\n\t\t%let etls_maxkey = 0;\n\n\t/*---- Slowly Changing Dimension Type 2 Beginning/End Date Method  ----*/\n\t/* Data merge the cross-reference and source tables  */\n\tdata work.etls_newrcds\n\t\t(drop = ETLS_STGDIGEST DIGEST_VALUE NewMaxKey ETLS_KEY ETLS_FROMDATE \n\t\tETLS_CLSDATE ETLS_TODATE %if %length(&type1changes.) > 0 %then ETLS_TYPE1DIGEST DIGEST_VALUE_TYPE1;)\n\t\twork.etls_match\n\t\t(drop = ETLS_STGDIGEST DIGEST_VALUE NewMaxKey ETLS_KEY ETLS_FROMDATE \n\t\tETLS_CLSDATE ETLS_TODATE %if %length(&type1changes.) > 0 %then ETLS_TYPE1DIGEST DIGEST_VALUE_TYPE1;)\n\t\twork.etls_close\n\t\t(keep = ETLS_KEY ETLS_CLSDATE)\n\t\t%if %length(&type1changes.) > 0 %then %do;\n\t\t\twork.etls_type1\n\t\t\t\t(keep = ETLS_KEY &type1changes.)\n\t\t%end;\n\t\t;\n\t\tretain NewMaxKey &etls_maxkey;\n\t\tmerge work.etls_source(in=inSort rename=(DIGEST_VALUE = ETLS_STGDIGEST %if %length(&type1changes.) > 0 %then DIGEST_VALUE_TYPE1 = ETLS_TYPE1DIGEST;))\n\t\twork.etls_sortedxref (in=inXref rename=(\n\t\t&generatedkey. = ETLS_KEY\n\t\t&begindate. = ETLS_FROMDATE\n\t\t&enddate. = ETLS_TODATE));\n\t\tby &businesskey.;\n\t\tattrib ETLS_CLSDATE length=8 format = Datetime20.;\n\n\t\t/* Process changes made to existing records  */\n\t\tif inSort and inXref then do;\n\t\t\tif last.&last_word. then\n\t\t\t\t&currentind. = 'Y';\n\t\t\telse &currentind. = 'N';\n\n\t\t\tif ETLS_STGDIGEST NE DIGEST_VALUE then do;\n\t\t\t\tif &begindate. eq . then\n\t\t\t\t\t&begindate. = &etls_begdate.;\n\n\t\t\t\t/* Ignore history records, only accept changes where the cross reference  */\n\t\t\t\t/*  beginning date is less than the source beginning date                 */\n\t\t\t\tif ETLS_FROMDATE < &begindate. then do;\n\t\t\t\t\tif &enddate. eq . then\n\t\t\t\t\t\t&enddate. = &etls_enddate.;\n\n\t\t\t\t\t/* Save off the close date  */\n\t\t\t\t\tif ETLS_TODATE = &etls_enddate. or ETLS_TODATE > &begindate. then do;\n\t\t\t\t\t\tif ETLS_FROMDATE < &begindate. then\n\t\t\t\t\t\t\tETLS_CLSDATE = &begindate. - 1;\n\t\t\t\t\t\telse ETLS_CLSDATE = ETLS_FROMDATE;\n\t\t\t\t\t\toutput work.etls_close;\n\t\t\t\t\tend;\n\n\t\t\t\t\tNewMaxKey = sum(NewMaxKey, 1);\n\t\t\t\t\t&generatedkey. = NewMaxKey;\n\n\t\t\t\t\t/* Overwrite the values to compare new records with from cross-reference   */\n\t\t\t\t\t/* variable values to the new current values from source  */\n\t\t\t\t\tDIGEST_VALUE = ETLS_STGDIGEST;\n\t\t\t\t\tETLS_FROMDATE = &begindate.;\n\t\t\t\t\tETLS_TODATE = &enddate.;\n\t\t\t\t\toutput work.etls_match;\n\t\t\t\tend;\n\t\t\tend;/*  End of digest values not equal   */\n\t\t\telse do;\n\t\t\t\tif &enddate. ne . then do;\n\n\t\t\t\t\t/* If the cross-reference end date is greater then the source end date then  */\n\t\t\t\t\t/*  close out the target record with the source end date                     */\n\t\t\t\t\tif last.&last_word. then\n\t\t\t\t\t\tif ETLS_TODATE gt &enddate. then do;\n\t\t\t\t\t\tETLS_CLSDATE = &enddate.;\n\t\t\t\t\t\toutput work.etls_close;\n\t\t\t\t\tend;\n\t\t\t\tend;\n\n\t\t\t\t/* If the source beginning date is greater then both the cross-reference  */\n\t\t\t\t/*  beginning and end date, then reactivate the closed out record         */\n\t\t\t\tif &begindate. gt ETLS_FROMDATE and\n\t\t\t\t\t&begindate. gt ETLS_TODATE then do;\n\t\t\t\t\tif &enddate. eq . then\n\t\t\t\t\t\t&enddate. = &etls_enddate.;\n\t\t\t\t\tNewMaxKey = sum(NewMaxKey, 1);\n\t\t\t\t\t&generatedkey. = NewMaxKey;\n\n\t\t\t\t\t/* Update the cross-reference varaibles to the new current values  */\n\t\t\t\t\tDIGEST_VALUE = ETLS_STGDIGEST;\n\t\t\t\t\tETLS_FROMDATE = &begindate.;\n\t\t\t\t\tETLS_TODATE = &enddate.;\n\t\t\t\t\toutput work.etls_match;\n\t\t\t\tend;\n\n\t\t\t\t%if %length(&type1changes.) > 0 %then %do;\n\t\t\t\telse do;\n\n\t\t\t\t\t/* Output to the type 1 work table if there are type 1 column changes  */\n\t\t\t\t\tif ETLS_TYPE1DIGEST NE DIGEST_VALUE_TYPE1 then\n\t\t\t\t\t\tif last.&last_word. then do;\n\t\t\t\t\t\toutput work.etls_type1;\n\t\t\t\t\tend;\n\t\t\t\tend;\n\t\t\t\t%end;\n\t\t\tend;  /* End of digest values are equal  */\n\t\tend;  /* End of inSort and inXref  */\n\n\t\t/* Process new records  */\n\t\telse if inSort and not inXref then do;\n\t\t\tNewMaxKey = sum(NewMaxKey, 1);\n\t\t\t&generatedkey. = NewMaxKey;\n\n\t\t\tif last.&last_word. then\n\t\t\t\t&currentind. = 'Y';\n\t\t\telse &currentind. = 'N';\n\n\t\t\tif &begindate. eq . then\n\t\t\t\t&begindate. = &etls_begdate.;\n\n\t\t\tif &enddate. eq . then\n\t\t\t\t&enddate. = &etls_enddate.;\n\t\t\toutput work.etls_newrcds;\n\t\tend;\n\n\t\t%if %upcase(&closeout.) = YES %then %do;\n\n\t\t\t/* Close out any records that are in the xref table but not in the source.  */\n\t\telse if inXref and not inSort then do;\n\t\t\tETLS_CLSDATE = DATETIME();\n\t\t\toutput work.etls_close;\n\t\tend;\n\t\t%end;\n\trun;\n\n\t/* Sort the output from the data merge step  */\n\tproc sort data=work.etls_close nodupkey;\n\t\tby ETLS_KEY;\n\trun;\n\n\t%if %length(&type1changes.) > 0 %then %do;\n\n\t\tproc sort data=work.etls_type1 nodupkey;\n\t\t\tby ETLS_KEY;\n\t\trun;\n\n\t%end;\n\n\t/* Save record counts into macro: \n\t\tetls_updatecnt \n\t*/\n\t%let etls_recCheckExist = 0;\n\t%let etls_updatecnt = 0;\n\t%macro etls_recordCheck;\n\t\t%let etls_recCheckExist = %eval(%sysfunc(exist(work.etls_close, DATA)) or \n\t\t\t%sysfunc(exist(work.etls_close, VIEW)));\n\n\t\t%if (&etls_recCheckExist) %then %do;\n\t\t\t%local etls_syntaxcheck;\n\t\t\t%let etls_syntaxcheck = %sysfunc(getoption(syntaxcheck));\n\n\t\t\t/* Turn off syntaxcheck option to perform following steps  */\n\t\t\toptions nosyntaxcheck;\n\n\t\t\tproc contents data = work.etls_close out = work.etls_contents(keep = nobs) noprint;\n\t\t\trun;\n\n\t\t\tdata _null_;\n\t\t\t\tset work.etls_contents (obs = 1);\n\t\t\t\tcall symput(\"etls_updatecnt\", left(put(nobs,32.)));\n\t\t\trun;\n\n\t\t\tproc datasets lib = work nolist nowarn memtype = (data view);\n\t\t\t\tdelete etls_contents;\n\t\t\tquit;\n\n\t\t\t/* Reset syntaxcheck option to previous setting  */\n\t\t\toptions &etls_syntaxcheck;\n\t\t%end;\n\t%mend etls_recordCheck;\n\t%etls_recordCheck;\n\n\t/* Save record counts into macro: \n\t\tetls_matchcnt \n\t*/\n\t%let etls_recCheckExist = 0;\n\t%let etls_matchcnt = 0;\n\t%macro etls_recordCheck;\n\t\t%let etls_recCheckExist = %eval(%sysfunc(exist(work.etls_match, DATA)) or \n\t\t\t%sysfunc(exist(work.etls_match, VIEW)));\n\n\t\t%if (&etls_recCheckExist) %then %do;\n\t\t\t%local etls_syntaxcheck;\n\t\t\t%let etls_syntaxcheck = %sysfunc(getoption(syntaxcheck));\n\n\t\t\t/* Turn off syntaxcheck option to perform following steps  */\n\t\t\toptions nosyntaxcheck;\n\n\t\t\tproc contents data = work.etls_match out = work.etls_contents(keep = nobs) noprint;\n\t\t\trun;\n\n\t\t\tdata _null_;\n\t\t\t\tset work.etls_contents (obs = 1);\n\t\t\t\tcall symput(\"etls_matchcnt\", left(put(nobs,32.)));\n\t\t\trun;\n\n\t\t\tproc datasets lib = work nolist nowarn memtype = (data view);\n\t\t\t\tdelete etls_contents;\n\t\t\tquit;\n\n\t\t\t/* Reset syntaxcheck option to previous setting  */\n\t\t\toptions &etls_syntaxcheck;\n\t\t%end;\n\t%mend etls_recordCheck;\n\t%etls_recordCheck;\n\n\t/* Save record counts into macro: \n\t\tetls_newcnt\n\t*/\n\t%let etls_recCheckExist = 0;\n\t%let etls_newcnt = 0;\n\t%macro etls_recordCheck;\n\t\t%let etls_recCheckExist = %eval(%sysfunc(exist(work.etls_newrcds, DATA)) or \n\t\t\t%sysfunc(exist(work.etls_newrcds, VIEW)));\n\n\t\t%if (&etls_recCheckExist) %then %do;\n\t\t\t%local etls_syntaxcheck;\n\t\t\t%let etls_syntaxcheck = %sysfunc(getoption(syntaxcheck));\n\n\t\t\t/* Turn off syntaxcheck option to perform following steps  */\n\t\t\toptions nosyntaxcheck;\n\n\t\t\tproc contents data = work.etls_newrcds out = work.etls_contents(keep = nobs) noprint;\n\t\t\trun;\n\n\t\t\tdata _null_;\n\t\t\t\tset work.etls_contents (obs = 1);\n\t\t\t\tcall symput(\"etls_newcnt\", left(put(nobs,32.)));\n\t\t\trun;\n\n\t\t\tproc datasets lib = work nolist nowarn memtype = (data view);\n\t\t\t\tdelete etls_contents;\n\t\t\tquit;\n\n\t\t\t/* Reset syntaxcheck option to previous setting  */\n\t\t\toptions &etls_syntaxcheck;\n\t\t%end;\n\t%mend etls_recordCheck;\n\t%etls_recordCheck;\n\n\t%if %length(&type1changes.) > 0 %then %do;\n\n\t\t/* Save record counts into macro: \n\t\t\tetls_type1cnt\n\t\t*/\n\t\t%let etls_recCheckExist = 0;\n\t\t%let etls_type1cnt = 0;\n\t\t%macro etls_recordCheck;\n\t\t\t%let etls_recCheckExist = %eval(%sysfunc(exist(work.etls_type1, DATA)) or \n\t\t\t\t%sysfunc(exist(work.etls_type1, VIEW)));\n\n\t\t\t%if (&etls_recCheckExist) %then %do;\n\t\t\t\t%local etls_syntaxcheck;\n\t\t\t\t%let etls_syntaxcheck = %sysfunc(getoption(syntaxcheck));\n\n\t\t\t\t/* Turn off syntaxcheck option to perform following steps  */\n\t\t\t\toptions nosyntaxcheck;\n\n\t\t\t\tproc contents data = work.etls_type1 out = work.etls_contents(keep = nobs) noprint;\n\t\t\t\trun;\n\n\t\t\t\tdata _null_;\n\t\t\t\t\tset work.etls_contents (obs = 1);\n\t\t\t\t\tcall symput(\"etls_type1cnt\", left(put(nobs,32.)));\n\t\t\t\trun;\n\n\t\t\t\tproc datasets lib = work nolist nowarn memtype = (data view);\n\t\t\t\t\tdelete etls_contents;\n\t\t\t\tquit;\n\n\t\t\t\t/* Reset syntaxcheck option to previous setting  */\n\t\t\t\toptions &etls_syntaxcheck;\n\t\t\t%end;\n\t\t%mend etls_recordCheck;\n\t\t%etls_recordCheck;\n\t%end;\n\n\t/* Save record counts into macro: \n\t\tetls_recordsBefore\n\t*/\n\t%let etls_recCheckExist = 0;\n\t%let etls_recordsBefore = 0;\n\t%macro etls_recordCheck;\n\t\t%let etls_recCheckExist = %eval(%sysfunc(exist(&output_table1., DATA)) or \n\t\t\t%sysfunc(exist(&output_table1., VIEW)));\n\n\t\t%if (&etls_recCheckExist) %then %do;\n\t\t\t%local etls_syntaxcheck;\n\t\t\t%let etls_syntaxcheck = %sysfunc(getoption(syntaxcheck));\n\n\t\t\t/* Turn off syntaxcheck option to perform following steps  */\n\t\t\toptions nosyntaxcheck;\n\n\t\t\tproc contents data = &output_table1. out = work.etls_contents(keep = nobs) noprint;\n\t\t\trun;\n\n\t\t\tdata _null_;\n\t\t\t\tset work.etls_contents (obs = 1);\n\t\t\t\tcall symput(\"etls_recordsBefore\", left(put(nobs,32.)));\n\t\t\trun;\n\n\t\t\tproc datasets lib = work nolist nowarn memtype = (data view);\n\t\t\t\tdelete etls_contents;\n\t\t\tquit;\n\n\t\t\t/* Reset syntaxcheck option to previous setting  */\n\t\t\toptions &etls_syntaxcheck;\n\t\t%end;\n\t%mend etls_recordCheck;\n\t%etls_recordCheck;\n\n\t%let etls_table = %nrquote(%scan(&output_table1.,2,.));\n\t%let etls_lib   = %nrquote(%scan(&output_table1.,1,.));\n\n\t%if %length(&type1changes.) > 0 %then %do;\n\n\t\t/* Check to see if the update counts are greater than zero  */\n\t\t%if &etls_updatecnt le 0 and &etls_matchcnt le 0 and &etls_newcnt le 0 and &etls_type1cnt le 0 %then\n\t\t\t%goto scdldout;\n\t%end;\n\t%else %do;\n\n\t\t/* Check to see if the update counts are greater than zero  */\n\t\t%if &etls_updatecnt le 0 and &etls_matchcnt le 0 and &etls_newcnt le 0 %then\n\t\t\t%goto scdldout;\n\t%end;\n\n\t/*---- Start of target table update  ----*/\n\t%if &etls_updatecnt gt 0 %then %do;\n\n\t\tdata &output_table1.;\n\t\t\tmodify &output_table1.\n\t\t\t\twork.etls_close\n\t\t\t\t(rename = (ETLS_KEY = &generatedkey.))\n\t\t\t\tupdatemode=nomissingcheck;\n\t\t\tby &generatedkey.;\n\t\t\t&enddate. = ETLS_CLSDATE;\n\t\t\t&currentind. = 'N';\n\n\t\t\tif %sysrc(_SOK) eq _iorc_ then\n\t\t\t\treplace;\n\t\t\t_iorc_ = 0;\n\t\t\t_error_ = 0;\n\t\trun;\n\n\t%end;\n\t%else %do;\n\t\t%put %str(NOTE: No records were closed on target table.);\n\t%end;\n\n\t%if %length(&type1changes.) > 0 %then %do;\n\t\t%if &etls_type1cnt gt 0 %then %do;\n\n\t\t\tdata &output_table1.;\n\t\t\t\tmodify &output_table1.\n\t\t\t\t\twork.etls_type1\n\t\t\t\t\t(rename = (ETLS_KEY = &generatedkey.))\n\t\t\t\t\tupdatemode=nomissingcheck;\n\t\t\t\tby &generatedkey.;\n\n\t\t\t\tif %sysrc(_SOK) eq _iorc_ then\n\t\t\t\t\treplace;\n\t\t\t\t_iorc_ = 0;\n\t\t\t\t_error_ = 0;\n\t\t\trun;\n\n\t\t%end;\n\t\t%else %do;\n\t\t\t%put %str(NOTE: No target table type 1 update records were found.);\n\t\t%end;\n\t%end;\n\n\t/*---- Append the new records and matching datasets  ----*/\n\t%if &etls_matchcnt gt 0 %then %do;\n\n\t\tproc append base = &output_table1.\n\n\t\t\tdata = work.etls_match force;\n\t\trun;\n\n\t%end;\n\n\t%if &etls_newcnt gt 0 %then %do;\n\n\t\tproc append base = &output_table1.\n\n\t\t\tdata = work.etls_newrcds force;\n\t\trun;\n\n\t%end;\n\t%else %do;\n\t\t%put %str(NOTE: No new dimension records were added to target table.);\n\t%end;\n\n\t/* Delete the work tables  */\n\tproc datasets lib=work nolist nowarn memtype = (data view);\n\t\tdelete etls_newrcds;\n\t\tdelete etls_match;\n\t\tdelete etls_close;\n\n\t\t%if %length(&type1changes.) > 0 %then %do;\n\t\t\tdelete etls_type1;\n\t\t%end;\n\n\t\tdelete etls_sortedxref;\n\t\tdelete etls_source;\n\tquit;\n\n\t%goto scdldout;\n\n%error:\n\t%let syscc = 9999;\n\n%scdldout:\n\n\t/* Save record counts into macro: \n\t\tetls_recordsAfter\n\t*/\n\t%let etls_recCheckExist = 0;\n\t%let etls_recordsAfter = 0;\n\t%macro etls_recordCheck;\n\t\t%let etls_recCheckExist = %eval(%sysfunc(exist(&output_table1., DATA)) or \n\t\t\t%sysfunc(exist(&output_table1., VIEW)));\n\n\t\t%if (&etls_recCheckExist) %then %do;\n\t\t\t%local etls_syntaxcheck;\n\t\t\t%let etls_syntaxcheck = %sysfunc(getoption(syntaxcheck));\n\n\t\t\t/* Turn off syntaxcheck option to perform following steps  */\n\t\t\toptions nosyntaxcheck;\n\n\t\t\tproc contents data = &output_table1. out = work.etls_contents(keep = nobs) noprint;\n\t\t\trun;\n\n\t\t\tdata _null_;\n\t\t\t\tset work.etls_contents (obs = 1);\n\t\t\t\tcall symput(\"etls_recordsAfter\", left(put(nobs,32.)));\n\t\t\trun;\n\n\t\t\tproc datasets lib = work nolist nowarn memtype = (data view);\n\t\t\t\tdelete etls_contents;\n\t\t\tquit;\n\n\t\t\t/* Reset syntaxcheck option to previous setting  */\n\t\t\toptions &etls_syntaxcheck;\n\t\t%end;\n\t%mend etls_recordCheck;\n\n\t%etls_recordCheck;\n\n\tproc datasets lib = work nolist nowarn memtype = (data view);\n\t\tdelete temp0;\n\tquit;\n\n%mend scdloader;\n\n%let businesskey=;\n%let detectchanges=;\n%let type1changes=;\n%let loopcol=;\n\n%macro Vars(var=);\n\t%let newVar=;\n\n\t%do i = 1 %to &&&var._count;\n\t\t%let newVar=%sysfunc(catx( ,&newVar &&&var._&i._name));\n\t%end;\n\n\t%put &newVar;\n\t%let &var = &newVar;\n%mend;\n\n%Vars(var=businesskey);\n%Vars(var=detectchanges);\n%Vars(var=type1changes);\n%Vars(var=loopcol);\n\n/* Execute the SCD Type 2 Loader  */\n%macro scdexec( input_table1=\n\t\t\t,loopcol=);\n\t%if %length(&loopcol.) = 0 %then %do;\n\t\t%scdloader( begindate=&begindate.\n\t\t\t,enddate=&enddate.\n\t\t\t,etls_begdate=%unquote(&etls_begdate.)\n\t\t\t,etls_enddate=%unquote(&etls_enddate.)\n\t\t\t,businesskey=&businesskey.\n\t\t\t,generatedkey=&generatedkey.\n\t\t\t,currentind=&currentind.\n\t\t\t,detectchanges=&detectchanges.\n\t\t\t,type1changes=&type1changes.\n\t\t\t,input_table1=&input_table1.\n\t\t\t,output_table1=&output_table1.\n\t\t\t,closeout=&closeout.\n\t\t\t);\n\t%end;\n\t%else %do;\n\n\t\tproc sql noprint;\n\t\t\tselect count(*) into :idx\n\t\t\t\tfrom dictionary.indexes\n\t\t\t\t\twhere upcase(libname) = \"%upcase(%scan(&input_table1.,1,.))\"\n\t\t\t\t\t\tand upcase(memname) = \"%upcase(%scan(&input_table1.,2,.))\"\n\t\t\t\t\t\tand upcase(indxname) = \"%upcase(&loopcol.)\";\n\t\tquit;\n\n\t\t%if &idx. = 0 %then %do;\n\n\t\t\tproc datasets lib = %scan(&input_table1.,1,.) nolist;\n\t\t\t\tmodify %scan(&input_table1.,2,.);\n\t\t\t\tindex create &loopcol.;\n\t\t\trun;\n\n\t\t\tquit;\n\n\t\t%end;\n\n\t\tproc sort data = &input_table1. (keep=&loopcol.) nodupkey out = temp1;\n\t\t\tby &loopcol.;\n\t\trun;\n\n\t\tdata _null_;\n\t\t\tset temp1;\n\t\t\tcall execute('%nrstr(%scdloader(begindate=&begindate,enddate=&enddate,etls_begdate='!!strip(&loopcol)!!',etls_enddate=%unquote(&etls_enddate.),businesskey=&businesskey,generatedkey=&generatedkey,currentind=&currentind,detectchanges=&detectchanges,type1changes=&type1changes,input_table1=&input_table1,output_table1=&output_table1,closeout=&closeout.,loopcol=&loopcol,loopval='!!strip(&loopcol)!!'));');\n\t\trun;\n\n\t\tproc datasets lib = work nolist nowarn memtype = (data view);\n\t\t\tdelete temp1;\n\t\tquit;\n\n\t%end;\n%mend scdexec;\n\n%scdexec( input_table1=&input_table1.\n\t,loopcol=&loopcol.)"},"properties":{},"ui":"{\n\t\"showPageContentOnly\": true,\n\t\"pages\": [\n\t\t{\n\t\t\t\"id\": \"inputPage\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"SCD Loader Settings\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"input_table1\",\n\t\t\t\t\t\"type\": \"inputtable\",\n\t\t\t\t\t\"label\": \"Input Table\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"output_table1\",\n\t\t\t\t\t\"type\": \"outputtable\",\n\t\t\t\t\t\"label\": \"Output Table\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"section2\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Business Key\",\n\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"businesskey\",\n\t\t\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\t\t\"label\": \"Select one or more columns to be designated as the business key or natural key:\",\n\t\t\t\t\t\t\t\"table\": \"input_table1\",\n\t\t\t\t\t\t\t\"order\": true,\n\t\t\t\t\t\t\t\"columntype\": \"a\",\n\t\t\t\t\t\t\t\"max\": 20,\n\t\t\t\t\t\t\t\"min\": 1\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"section3\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Generated Key\",\n\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"generatedkey\",\n\t\t\t\t\t\t\t\"type\": \"newcolumn\",\n\t\t\t\t\t\t\t\"label\": \"Generated Key:\",\n\t\t\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\t\t\"hideproperties\": false,\n\t\t\t\t\t\t\t\"readonly\": false\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"section4\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Detect Changes\",\n\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"detectchanges\",\n\t\t\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\t\t\"label\": \"Select columns to be used to detect changes in the target table:\",\n\t\t\t\t\t\t\t\"table\": \"input_table1\",\n\t\t\t\t\t\t\t\"order\": true,\n\t\t\t\t\t\t\t\"columntype\": \"a\",\n\t\t\t\t\t\t\t\"max\": 50,\n\t\t\t\t\t\t\t\"min\": 0\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"section5\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Change Tracking\",\n\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"begindate\",\n\t\t\t\t\t\t\t\"type\": \"newcolumn\",\n\t\t\t\t\t\t\t\"label\": \"Begin Date:\",\n\t\t\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\t\t\"hideproperties\": false,\n\t\t\t\t\t\t\t\"readonly\": false\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"enddate\",\n\t\t\t\t\t\t\t\"type\": \"newcolumn\",\n\t\t\t\t\t\t\t\"label\": \"End Date:\",\n\t\t\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\t\t\"hideproperties\": false,\n\t\t\t\t\t\t\t\"readonly\": false\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"currentind\",\n\t\t\t\t\t\t\t\"type\": \"newcolumn\",\n\t\t\t\t\t\t\t\"label\": \"Current Indicator:\",\n\t\t\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\t\t\"hideproperties\": false,\n\t\t\t\t\t\t\t\"readonly\": false\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"etls_begdate\",\n\t\t\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\t\t\"label\": \"Add expression for Begin Data:\",\n\t\t\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\t\t\"required\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"etls_enddate\",\n\t\t\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\t\t\"label\": \"Add expression for End Data:\",\n\t\t\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\t\t\"required\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"section6\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Type 1 Columns\",\n\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"type1changes\",\n\t\t\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\t\t\"label\": \"Select the columns whose values should be overwritten:\",\n\t\t\t\t\t\t\t\"table\": \"input_table1\",\n\t\t\t\t\t\t\t\"order\": true,\n\t\t\t\t\t\t\t\"columntype\": \"a\",\n\t\t\t\t\t\t\t\"max\": 50,\n\t\t\t\t\t\t\t\"min\": 0\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"section7\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Loop Column\",\n\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"loopcol\",\n\t\t\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\t\t\"label\": \"Select the column to loop over (Optional):\",\n\t\t\t\t\t\t\t\"table\": \"input_table1\",\n\t\t\t\t\t\t\t\"order\": true,\n\t\t\t\t\t\t\t\"columntype\": \"n\",\n\t\t\t\t\t\t\t\"max\": 1,\n\t\t\t\t\t\t\t\"min\": 0\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"section8\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Options\",\n\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"closeout\",\n\t\t\t\t\t\t\t\"type\": \"dropdown\",\n\t\t\t\t\t\t\t\"label\": \"Close out records not in source table:\",\n\t\t\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"value\": \"Yes\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"value\": \"No\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\t\t\"placeholder\": \"\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"page1\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"About\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"text1\",\n\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\"text\": \"The \\\"SCD Loader\\\" Custom Step loads a target table and captures Type 2 as well as Type 1 changes. The SCD Loader is migrated from SAS Data Integration Studio.\\n\\nUSER INTERFACE\\n\\n- Business Key: Select one or more columns to be designated as business key or natural key.\\n\\n- Generated Key: Specify name of generated surrogate key.\\n\\n- Detect Changes: Select columns to be used to detect changes.\\n\\n- Begin Date: Specify name of column to contain begin date.\\n\\n- End Date: Specify name of column to contain end date.\\n\\n- Current Indicator: Specify name of column containing current row indicator.\\n\\n- Add expression for Begin Data: Specify expression for begin datetime for change tracking.\\n\\n- Add expression for End Data: Specify expression for end datetime for change tracking.\\n\\n- Select the columns whose values should be overwritten: Overwrite existing data in target table for specified columns.\\n\\n- Loop Column: Select a date column from the input table used to do sequential updates of the result table (this option is new for this Custom Step, and is used to indicate that you have duplicates on different dates for your business key)\\n\\n- Close out records not in source table: YES if records not in source table should be closed out.\\n\\n- Input Port 1: The source table. This table must not contain duplicates of your business key, unless you have specified a date-column in the Loop Column option.\\n\\n- Output Port 1:  The result table containing the selected columns from the base table and the new columns.\\n\\nVersion 1 (28SEP2022)\\n\\n\\n\\n\\n\\n\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t],\n\t\"syntaxversion\": \"1.3.0\",\n\t\"values\": {\n\t\t\"input_table1\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"output_table1\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"businesskey\": [],\n\t\t\"generatedkey\": {\n\t\t\t\"value\": \"generated_key\",\n\t\t\t\"type\": \"n\",\n\t\t\t\"length\": 8,\n\t\t\t\"format\": \"best32.\"\n\t\t},\n\t\t\"detectchanges\": [],\n\t\t\"begindate\": {\n\t\t\t\"length\": 8,\n\t\t\t\"type\": \"n\",\n\t\t\t\"value\": \"begin_dttm\",\n\t\t\t\"format\": \"datetime.\"\n\t\t},\n\t\t\"enddate\": {\n\t\t\t\"value\": \"end_dttm\",\n\t\t\t\"length\": 8,\n\t\t\t\"format\": \"datetime.\"\n\t\t},\n\t\t\"currentind\": {\n\t\t\t\"value\": \"current_indicator\",\n\t\t\t\"length\": 1\n\t\t},\n\t\t\"etls_begdate\": \"%SYSFUNC(DATETIME())\",\n\t\t\"etls_enddate\": \"'01JAN5999:00:00:00'DT\",\n\t\t\"type1changes\": [],\n\t\t\"loopcol\": [],\n\t\t\"closeout\": {\n\t\t\t\"value\": \"No\"\n\t\t}\n\t}\n}","flowMetadata":{"inputPorts":[{"name":"input_table1","displayName":"input_table1","minEntries":1,"maxEntries":1,"type":"table"}],"outputPorts":[{"name":"output_table1","displayName":"output_table1","description":"","minEntries":1,"maxEntries":1,"columnDelta":{"automaticMapping":[{"inputPort":"input_table1"}],"removeColumnArguments":[],"keepColumnArguments":[],"updateColumnArguments":["generatedkey","begindate","enddate","currentind"]},"type":"table"}]}}
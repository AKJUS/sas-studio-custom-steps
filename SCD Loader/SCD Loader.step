{"type":"code","name":"SCD Loader.step","displayName":"SCD Loader.step","description":"","templates":{"SAS":"/*==========================================================================* \n * Custom Step:     SCD loader                                              * \n * Transform:       SCD loader                                              * \n * Description:     This macro loads a target table and captures Type 2 as  *\n *                  as well as Type 1 changes.                              *           \n *==========================================================================*/ \n\n\n%let BEGINDATE=&BEGINDATE_NAME;\n%let ENDDATE=&ENDDATE_NAME;\n%let GENERATEDKEY=&GENERATEDKEY_NAME;\n%let CURRENTIND=&CURRENTIND_NAME;\n\n \n%macro scdloader( begindate=\n                 ,enddate=\n\t\t\t\t ,etls_begdate=\n\t\t\t\t ,etls_enddate=\n                 ,businesskey=\n                 ,generatedkey=\n\t\t\t\t ,currentind=\n                 ,detectchanges=\n\t\t\t\t ,type1changes=\n                 ,input_table1=\n                 ,output_table1=\n\t\t\t\t ,closeout=No\n\t\t\t\t ,loopcol=\n\t\t\t\t ,loopval=\n\t\t\t\t);\n\n   %if (%sysfunc(exist(&output_table1.)) eq 0) %then \n   %do;\n\n      proc sql;\n      %if %length(&loopcol.) = 0 %then %do;\n         create table &output_table1. as\n      %end;\n      %else %do;\n         create table &output_table1. (drop=&loopcol.)as\n      %end;\n            select\n               . as &generatedkey. length = 8,\n               *,\n               . as &begindate. length = 8\n                  format = Datetime20.,\n               . as &enddate. length = 8\n                  format = Datetime20.,\n               \"\" as &currentind. length = 1\n         from &input_table1. (obs=0)\n         ;\n      quit;\n\n   %end;\n\n   /*---- Temporary cross reference table being used  ----*/ \n   /* Delete any existing temporary cross-reference table  */ \n   proc datasets lib = work nolist nowarn memtype = (data view);\n      delete etls_sortedxref;\n   quit;\n   \n   /* Sort target table records before creating the temporary cross reference  */ \n   /*  table:                                                                  */ \n   proc sort data = &output_table1(where = (&currentind. = 'Y'))\n      out = work.etls_sortedxref(keep=&generatedkey. &businesskey. &begindate. &enddate. &currentind. &detectchanges.);\n      by &businesskey.;\n   run;\n\n   %let etls_str = '\"' ||KTRIM(KLEFT(%sysfunc(tranwrd(%quote(&detectchanges),%str( ),%str(%)%) || KTRIM%(KLEFT%())))) || '\"';\n   \n   %if %length(&type1changes.) = 0 %then %do;\n\n      /* Generate change digest (v1.1)  */ \n      data work.etls_sortedxref(keep = &generatedkey. &businesskey. &begindate. &enddate. DIGEST_VALUE);\n   \n         length etls_md5 $16.;\n         length DIGEST_VALUE $32.;\n      \n         set work.etls_sortedxref;\n      \n         by &businesskey.;\n      \n         etls_str = &etls_str;\n         etls_md5 = md5(etls_str);\n         DIGEST_VALUE = put(etls_md5, hex32.);\n   \n      run;\n\n   %end;\n   %else %do;\n\n      %let etls_str_type1 = '\"' ||KTRIM(KLEFT(%sysfunc(tranwrd(%quote(&type1changes),%str( ),%nrstr(%)%) || ' ' || KTRIM%(KLEFT%())))) || '\"';\n\n      /* Generate change digest (v1.1)  */ \n      data work.etls_sortedxref(keep = &generatedkey. &businesskey. &begindate. &enddate. DIGEST_VALUE DIGEST_VALUE_TYPE1);\n   \n         length etls_md5 $16.;\n         length DIGEST_VALUE $32.;\n         length DIGEST_VALUE_TYPE1 $32.;\n      \n         set work.etls_sortedxref;\n      \n         by &businesskey.;\n      \n         etls_str = &etls_str.;\n         etls_md5 = md5(etls_str);\n         DIGEST_VALUE = put(etls_md5, hex32.);\n         etls_str_type1 = &etls_str_type1.;\n         etls_md5 = md5(etls_str_type1);\n         DIGEST_VALUE_TYPE1 = put(etls_md5, $hex32.);\n   \n      run;\n\n   %end;\n\n   proc sql;\n   %if %length(&loopcol.) = 0 %then %do;\n      create table work.temp0 as\n   %end;\n   %else %do;\n      create table work.temp0 (drop=&loopcol.) as\n   %end;\n      select\n         . as &generatedkey. length = 8,\n         *,\n         . as &begindate. length = 8\n            format = Datetime20.,\n         . as &enddate. length = 8\n            format = Datetime20.,\n         \"\" as &currentind. length = 1\n      from &input_table1.\n   %if %length(&loopcol.) > 0 %then %do;\n      where &loopcol. = &loopval.\n   %end;\n      ;\n   quit;\n\n   %let SYSLAST = work.temp0;\n   \n   %let etls_lastTable = &SYSLAST; \n   %let etls_tableOptions = ; \n\n   %if %length(&type1changes.) = 0 %then %do;\n \n      /* Generate change digest (v1.1)  */ \n      data work.etls_source(drop=etls_str etls_md5 compress=no);\n         set &syslast;\n         length etls_md5 $16.;\n         length DIGEST_VALUE $32.;\n         etls_str = &etls_str.;\n         etls_md5 = MD5(etls_str);\n         DIGEST_VALUE=put(etls_md5, hex32.);\n      run;\n\n   %end;\n   %else %do;\n\n      /* Generate change digest (v1.1)  */ \n      data work.etls_source(drop=etls_str etls_md5  etls_str_type1 compress=no);\n         set &syslast;\n         length etls_md5 $16.;\n         length DIGEST_VALUE $32.;\n         length DIGEST_VALUE_TYPE1 $32.;\n         etls_str = &etls_str.;\n         etls_md5 = MD5(etls_str);\n         DIGEST_VALUE=put(etls_md5, hex32.);\n         etls_str_type1 = &etls_str_type1.;\n         etls_md5 = MD5(etls_str_type1);\n         DIGEST_VALUE_TYPE1 =put(etls_md5, $hex32.);\n      run;\n\n   %end;\n\n   /* Generate the from date expression  */ \n   %let etls_begdate = &etls_begdate;\n   /* Generate the default to date expression  */ \n   %let etls_enddate = &etls_enddate;\n   \n   /* Sort the source table by business key and beginning/from date columns.  */ \n   proc sort data=work.etls_source out=work.etls_source(compress=no);\n      by &businesskey. &begindate.;\n   run;\n\n   %let last_word = %scan(&businesskey,-1,%str( ));\n\n   /*---- Set beginning dates and close out any history records   ----*/ \n   data work.etls_source (drop = etls_sameday etls_cnt etls_closedate);\n   \n      set work.etls_source;\n      by &businesskey.;\n      \n      /* Set beginning dates if null  */ \n      if &begindate. eq . then\n         &begindate. = &etls_begdate.;\n         \n      if first.&last_word. then\n         etls_cnt = 0;\n      else\n         etls_cnt + 1;\n         \n      /* Close out any history records if they exist  */ \n      if not last.&last_word. then\n      do;\n      \n         obsnum = _n_ + 1;\n         set work.etls_source(keep = &begindate.\n                  rename = (&begindate. = etls_closedate))\n                  point = obsnum;\n                  \n         if etls_closedate eq . then\n            etls_closedate = &etls_begdate;\n            \n         if &begindate. eq etls_closedate then\n            etls_closedate = etls_closedate + (etls_cnt + 1);\n            \n         if &enddate. eq . then\n            &enddate. = etls_closedate - 1;\n            \n      end;\n      \n      /* Fix the beginning dates if needed  */ \n      etls_sameday = lag1(&begindate.);\n      if not first.&last_word. and etls_sameday eq &begindate. then\n         &begindate. = &begindate. + etls_cnt;\n         \n   run;\n\n   /*---- Generate the maximum generated key  ----*/ \n   /* Calculate the max generated key value and hold the value in the macro  */ \n   /*  variable &etls_maxkey                                                 */ \n   %let etls_maxkey = -1;\n   \n   proc sql noprint;\n      select compress(put(max(&generatedkey.), best32.))\n         into :etls_maxkey\n             from &output_table1.;\n      quit;\n      \n      /* If \"etls_maxkey\" does not have a value, then set it to zero.  */ \n      %if (&etls_maxkey eq .)\n         %then %let etls_maxkey = 0;\n         \n   /*---- Slowly Changing Dimension Type 2 Beginning/End Date Method  ----*/ \n   /* Data merge the cross-reference and source tables  */ \n   data work.etls_newrcds\n          (drop = ETLS_STGDIGEST DIGEST_VALUE NewMaxKey ETLS_KEY ETLS_FROMDATE \n                     ETLS_CLSDATE ETLS_TODATE %if %length(&type1changes.) > 0 %then ETLS_TYPE1DIGEST DIGEST_VALUE_TYPE1;)\n      work.etls_match\n          (drop = ETLS_STGDIGEST DIGEST_VALUE NewMaxKey ETLS_KEY ETLS_FROMDATE \n                     ETLS_CLSDATE ETLS_TODATE %if %length(&type1changes.) > 0 %then ETLS_TYPE1DIGEST DIGEST_VALUE_TYPE1;)\n      work.etls_close\n          (keep = ETLS_KEY ETLS_CLSDATE)\n   %if %length(&type1changes.) > 0 %then %do;\n      work.etls_type1\n          (keep = ETLS_KEY &type1changes.)\n   %end;\n      ;\n      retain NewMaxKey &etls_maxkey;\n      \n      merge work.etls_source(in=inSort rename=(DIGEST_VALUE = ETLS_STGDIGEST %if %length(&type1changes.) > 0 %then DIGEST_VALUE_TYPE1 = ETLS_TYPE1DIGEST;))\n         work.etls_sortedxref (in=inXref rename=(\n            &generatedkey. = ETLS_KEY\n               &begindate. = ETLS_FROMDATE\n                 &enddate. = ETLS_TODATE));\n      by &businesskey.;\n      \n      attrib ETLS_CLSDATE length=8 format = Datetime20.;\n      \n      /* Process changes made to existing records  */ \n      if inSort and inXref then\n      do;\n      \n         if last.&last_word. then\n            &currentind. = 'Y';\n         else\n            &currentind. = 'N';\n            \n         if ETLS_STGDIGEST NE DIGEST_VALUE then\n         do;\n         \n            if &begindate. eq . then\n               &begindate. = &etls_begdate.;\n               \n            /* Ignore history records, only accept changes where the cross reference  */ \n            /*  beginning date is less than the source beginning date                 */ \n            if ETLS_FROMDATE < &begindate. then\n            do;\n            \n               if &enddate. eq . then\n                  &enddate. = &etls_enddate.;\n                  \n               /* Save off the close date  */ \n               if ETLS_TODATE = &etls_enddate. or ETLS_TODATE > &begindate. then\n               do;\n               \n                  if ETLS_FROMDATE < &begindate. then\n                     ETLS_CLSDATE = &begindate. - 1;\n                  else ETLS_CLSDATE = ETLS_FROMDATE;\n                  \n                  output work.etls_close;\n                  \n               end;\n               \n               NewMaxKey = sum(NewMaxKey, 1);\n               &generatedkey. = NewMaxKey;\n               \n               /* Overwrite the values to compare new records with from cross-reference   */ \n               /* variable values to the new current values from source  */ \n               DIGEST_VALUE = ETLS_STGDIGEST;\n               ETLS_FROMDATE = &begindate.;\n               ETLS_TODATE = &enddate.;\n               \n               output work.etls_match;\n               \n            end;\n        \n         end;/*  End of digest values not equal   */          \n         \n         else do;\n         \n            if &enddate. ne . then\n            do;\n            \n               /* If the cross-reference end date is greater then the source end date then  */ \n               /*  close out the target record with the source end date                     */ \n               if last.&last_word. then\n                  if ETLS_TODATE gt &enddate. then\n                  do;\n                  \n                     ETLS_CLSDATE = &enddate.;\n                     output work.etls_close;\n                     \n                  end;\n                  \n            end;\n            \n            /* If the source beginning date is greater then both the cross-reference  */ \n            /*  beginning and end date, then reactivate the closed out record         */ \n            if &begindate. gt ETLS_FROMDATE and\n               &begindate. gt ETLS_TODATE then\n            do;\n            \n               if &enddate. eq . then\n                  &enddate. = &etls_enddate.;\n                  \n               NewMaxKey = sum(NewMaxKey, 1);\n               &generatedkey. = NewMaxKey;\n               \n               /* Update the cross-reference varaibles to the new current values  */ \n               DIGEST_VALUE = ETLS_STGDIGEST;\n               ETLS_FROMDATE = &begindate.;\n               ETLS_TODATE = &enddate.;\n               \n               output work.etls_match;\n               \n            end;\n\n\t\t\t%if %length(&type1changes.) > 0 %then %do;\n\n               else do;\n            \n                  /* Output to the type 1 work table if there are type 1 column changes  */ \n                  if ETLS_TYPE1DIGEST NE DIGEST_VALUE_TYPE1 then\n                     if last.&last_word. then\n                     do;\n                        output work.etls_type1;\n                     end;\n                  \n               end;\n\n\t\t\t%end;\n            \n         end;  /* End of digest values are equal  */ \n         \n      end;  /* End of inSort and inXref  */ \n      \n      /* Process new records  */ \n      else if inSort and not inXref then \n      do;\n      \n         NewMaxKey = sum(NewMaxKey, 1);\n         \n         &generatedkey. = NewMaxKey;\n         \n         if last.&last_word. then\n            &currentind. = 'Y';\n         else\n            &currentind. = 'N';\n            \n         if &begindate. eq . then\n            &begindate. = &etls_begdate.;\n         if &enddate. eq . then \n            &enddate. = &etls_enddate.;\n            \n         output work.etls_newrcds;\n         \n      end;\n\n      %if %upcase(&closeout.) = YES %then %do;\n\n         /* Close out any records that are in the xref table but not in the source.  */ \n         else if inXref and not inSort then\n         do;\n         \n            ETLS_CLSDATE = DATETIME();\n            \n            output work.etls_close;\n            \n         end;\n\n      %end;    \n      \n   run;\n\n   /* Sort the output from the data merge step  */ \n   proc sort data=work.etls_close nodupkey;\n      by ETLS_KEY;\n   run;\n\n   %if %length(&type1changes.) > 0 %then %do;\n\n      proc sort data=work.etls_type1 nodupkey;\n         by ETLS_KEY;\n      run;\n\n   %end;\n   \n   /* Save record counts into macros  */ \n   %let etls_recCheckExist = 0; \n   %let etls_updatecnt = 0; \n   %macro etls_recordCheck; \n      %let etls_recCheckExist = %eval(%sysfunc(exist(work.etls_close, DATA)) or \n            %sysfunc(exist(work.etls_close, VIEW))); \n      \n      %if (&etls_recCheckExist) %then\n      %do;\n         %local etls_syntaxcheck; \n         %let etls_syntaxcheck = %sysfunc(getoption(syntaxcheck)); \n         /* Turn off syntaxcheck option to perform following steps  */ \n         options nosyntaxcheck;\n         \n         proc contents data = work.etls_close out = work.etls_contents(keep = nobs) noprint; \n         run; \n         \n         data _null_; \n            set work.etls_contents (obs = 1); \n            call symput(\"etls_updatecnt\", left(put(nobs,32.))); \n         run;\n         \n         proc datasets lib = work nolist nowarn memtype = (data view);\n            delete etls_contents;\n         quit;\n         \n         /* Reset syntaxcheck option to previous setting  */ \n         options &etls_syntaxcheck; \n      %end;\n   %mend etls_recordCheck;\n   %etls_recordCheck;\n    \n   %let etls_recCheckExist = 0; \n   %let etls_matchcnt = 0; \n   %macro etls_recordCheck; \n      %let etls_recCheckExist = %eval(%sysfunc(exist(work.etls_match, DATA)) or \n            %sysfunc(exist(work.etls_match, VIEW))); \n      \n      %if (&etls_recCheckExist) %then\n      %do;\n         %local etls_syntaxcheck; \n         %let etls_syntaxcheck = %sysfunc(getoption(syntaxcheck)); \n         /* Turn off syntaxcheck option to perform following steps  */ \n         options nosyntaxcheck;\n         \n         proc contents data = work.etls_match out = work.etls_contents(keep = nobs) noprint; \n         run; \n         \n         data _null_; \n            set work.etls_contents (obs = 1); \n            call symput(\"etls_matchcnt\", left(put(nobs,32.))); \n         run;\n         \n         proc datasets lib = work nolist nowarn memtype = (data view);\n            delete etls_contents;\n         quit;\n         \n         /* Reset syntaxcheck option to previous setting  */ \n         options &etls_syntaxcheck; \n      %end;\n   %mend etls_recordCheck;\n   %etls_recordCheck;\n   \n   %let etls_recCheckExist = 0; \n   %let etls_newcnt = 0; \n   %macro etls_recordCheck; \n      %let etls_recCheckExist = %eval(%sysfunc(exist(work.etls_newrcds, DATA)) or \n            %sysfunc(exist(work.etls_newrcds, VIEW))); \n      \n      %if (&etls_recCheckExist) %then\n      %do;\n         %local etls_syntaxcheck; \n         %let etls_syntaxcheck = %sysfunc(getoption(syntaxcheck)); \n         /* Turn off syntaxcheck option to perform following steps  */ \n         options nosyntaxcheck;\n         \n         proc contents data = work.etls_newrcds out = work.etls_contents(keep = nobs) noprint; \n         run; \n         \n         data _null_; \n            set work.etls_contents (obs = 1); \n            call symput(\"etls_newcnt\", left(put(nobs,32.))); \n         run;\n         \n         proc datasets lib = work nolist nowarn memtype = (data view);\n            delete etls_contents;\n         quit;\n         \n         /* Reset syntaxcheck option to previous setting  */ \n         options &etls_syntaxcheck; \n      %end;\n   %mend etls_recordCheck;\n   %etls_recordCheck;\n\n   %if %length(&type1changes.) > 0 %then %do;\n\n      %let etls_recCheckExist = 0; \n      %let etls_type1cnt = 0; \n      %macro etls_recordCheck; \n         %let etls_recCheckExist = %eval(%sysfunc(exist(work.etls_type1, DATA)) or \n               %sysfunc(exist(work.etls_type1, VIEW))); \n      \n         %if (&etls_recCheckExist) %then\n         %do;\n            %local etls_syntaxcheck; \n            %let etls_syntaxcheck = %sysfunc(getoption(syntaxcheck)); \n            /* Turn off syntaxcheck option to perform following steps  */ \n            options nosyntaxcheck;\n         \n            proc contents data = work.etls_type1 out = work.etls_contents(keep = nobs) noprint; \n            run; \n         \n            data _null_; \n               set work.etls_contents (obs = 1); \n               call symput(\"etls_type1cnt\", left(put(nobs,32.))); \n            run;\n         \n            proc datasets lib = work nolist nowarn memtype = (data view);\n               delete etls_contents;\n            quit;\n         \n            /* Reset syntaxcheck option to previous setting  */ \n            options &etls_syntaxcheck; \n         %end;\n      %mend etls_recordCheck;\n      %etls_recordCheck; \n\n   %end;\n   \n   /* Get number of records in table  */ \n   %let etls_recCheckExist = 0; \n   %let etls_recordsBefore = 0; \n   %macro etls_recordCheck; \n      %let etls_recCheckExist = %eval(%sysfunc(exist(&output_table1., DATA)) or \n            %sysfunc(exist(&output_table1., VIEW))); \n      \n      %if (&etls_recCheckExist) %then\n      %do;\n         %local etls_syntaxcheck; \n         %let etls_syntaxcheck = %sysfunc(getoption(syntaxcheck)); \n         /* Turn off syntaxcheck option to perform following steps  */ \n         options nosyntaxcheck;\n         \n         proc contents data = &output_table1. out = work.etls_contents(keep = nobs) noprint; \n         run; \n         \n         data _null_; \n            set work.etls_contents (obs = 1); \n            call symput(\"etls_recordsBefore\", left(put(nobs,32.))); \n         run;\n         \n         proc datasets lib = work nolist nowarn memtype = (data view);\n            delete etls_contents;\n         quit;\n         \n         /* Reset syntaxcheck option to previous setting  */ \n         options &etls_syntaxcheck; \n      %end;\n   %mend etls_recordCheck;\n   %etls_recordCheck;\n   \n   %let etls_table = %nrquote(%scan(&output_table1.,2,.));\n   %let etls_lib   = %nrquote(%scan(&output_table1.,1,.));\n\n   %if %length(&type1changes.) > 0 %then %do;\n \n      /* Check to see if the update counts are greater than zero  */ \n      %if &etls_updatecnt le 0 and &etls_matchcnt le 0 and &etls_newcnt le 0 and &etls_type1cnt le 0\n         %then %goto scdldout;\n\n   %end;\n   %else %do;\n\n      /* Check to see if the update counts are greater than zero  */ \n      %if &etls_updatecnt le 0 and &etls_matchcnt le 0 and &etls_newcnt le 0 \n         %then %goto scdldout;\n\n   %end;\n      \n   /*---- Start of target table update  ----*/ \n   %if &etls_updatecnt gt 0 %then\n   %do;\n   \n      data &output_table1.;\n      \n         modify &output_table1.\n            work.etls_close\n             (rename = (ETLS_KEY = &generatedkey.))\n             updatemode=nomissingcheck;\n            \n         by &generatedkey.;\n         \n         &enddate. = ETLS_CLSDATE;\n         \n         &currentind. = 'N';\n         \n         if %sysrc(_SOK) eq _iorc_ then \n            replace;\n            \n         _iorc_ = 0; \n         _error_ = 0;\n         \n      run;\n      \n   %end;\n   %else %do;\n   \n      %put %str(NOTE: No records were closed on target table.);\n      \n   %end;\n\n   %if %length(&type1changes.) > 0 %then %do;\n\n      %if &etls_type1cnt gt 0 %then\n      %do;\n   \n         data &output_table1.;\n      \n            modify &output_table1.\n               work.etls_type1\n                (rename = (ETLS_KEY = &generatedkey.))\n                updatemode=nomissingcheck;\n            \n            by &generatedkey.;\n         \n            if %sysrc(_SOK) eq _iorc_ then \n               replace;\n            \n            _iorc_ = 0; \n            _error_ = 0;\n         \n         run;\n  \n      %end;\n      %else %do;\n   \n         %put %str(NOTE: No target table type 1 update records were found.);\n      \n      %end;\n\n   %end;\n   \n   /*---- Append the new records and matching datasets  ----*/ \n   %if &etls_matchcnt gt 0 %then\n   %do;\n   \n      proc append base = &output_table1.\n      \n         data = work.etls_match force;\n      run;\n      \n   %end;\n   %if &etls_newcnt gt 0 %then\n   %do;\n   \n      proc append base = &output_table1.\n      \n         data = work.etls_newrcds force;\n      run;\n      \n   %end;\n   %else %do;\n   \n      %put %str(NOTE: No new dimension records were added to target table.);\n      \n   %end;\n   \n   /* Delete the work tables  */ \n   proc datasets lib=work nolist nowarn memtype = (data view);\n      delete etls_newrcds;\n      delete etls_match;\n      delete etls_close;\n   %if %length(&type1changes.) > 0 %then %do;\n      delete etls_type1;\n   %end;\n      delete etls_sortedxref;\n      delete etls_source;\n   quit;\n   \n   %goto scdldout;\n   %error:\n\n   %let syscc = 9999;\n      \n   %scdldout:\n\n   /* Get number of records in table  */ \n   %let etls_recCheckExist = 0; \n   %let etls_recordsAfter = 0; \n   %macro etls_recordCheck; \n      %let etls_recCheckExist = %eval(%sysfunc(exist(&output_table1., DATA)) or \n            %sysfunc(exist(&output_table1., VIEW))); \n        \n      %if (&etls_recCheckExist) %then\n      %do;\n         %local etls_syntaxcheck; \n         %let etls_syntaxcheck = %sysfunc(getoption(syntaxcheck)); \n         /* Turn off syntaxcheck option to perform following steps  */ \n         options nosyntaxcheck;\n            \n         proc contents data = &output_table1. out = work.etls_contents(keep = nobs) noprint; \n         run; \n            \n         data _null_; \n            set work.etls_contents (obs = 1); \n            call symput(\"etls_recordsAfter\", left(put(nobs,32.))); \n         run;\n            \n         proc datasets lib = work nolist nowarn memtype = (data view);\n            delete etls_contents;\n         quit;\n            \n         /* Reset syntaxcheck option to previous setting  */ \n         options &etls_syntaxcheck; \n      %end;\n   %mend etls_recordCheck;\n   %etls_recordCheck;\n\n   proc datasets lib = work nolist nowarn memtype = (data view);\n      delete temp0;\n   quit;\n      \n%mend scdloader;\n\n%let businesskey=;\n%let detectchanges=;\n%let type1changes=;\n%let loopcol=;\n\n%macro Vars(var=);\n   %let newVar=;\n   %do i = 1 %to &&&var._count;\n      %let newVar=%sysfunc(catx( ,&newVar &&&var._&i._name));\n   %end;\n   %put &newVar;\n   %let &var = &newVar;\n%mend;\n\n%Vars(var=businesskey);\n%Vars(var=detectchanges);\n%Vars(var=type1changes);\n%Vars(var=loopcol);\n\n/* Execute the SCD Type 2 Loader  */\n%macro scdexec( input_table1=\n               ,loopcol=);\n\n\n   %if %length(&loopcol.) = 0 %then %do;\n\n      %scdloader( begindate=&begindate.\n                 ,enddate=&enddate.\n   \t             ,etls_begdate=%unquote(&etls_begdate.)\n                 ,etls_enddate=%unquote(&etls_enddate.)\n                 ,businesskey=&businesskey.\n                 ,generatedkey=&generatedkey.\n                 ,currentind=&currentind.\n                 ,detectchanges=&detectchanges.\n                 ,type1changes=&type1changes.\n                 ,input_table1=&input_table1.\n                 ,output_table1=&output_table1.\n                 ,closeout=&closeout.\n                );\n\n   %end;\n   %else %do;\n\n      proc sql noprint;\n         select count(*) into :idx\n         from dictionary.indexes\n         where upcase(libname) = \"%upcase(%scan(&input_table1.,1,.))\"\n         and upcase(memname) = \"%upcase(%scan(&input_table1.,2,.))\"\n         and upcase(indxname) = \"%upcase(&loopcol.)\";\n      quit;\n\n      %if &idx. = 0 %then %do;\n\n         proc datasets lib = %scan(&input_table1.,1,.) nolist;\n         modify %scan(&input_table1.,2,.);\n         index create &loopcol.;\n         run;\n         quit;\n\n\t  %end;\n\n      proc sort data = &input_table1. (keep=&loopcol.) nodupkey out = temp1;\n\t  by &loopcol.;\n\t  run;\n\n      data _null_;\n\t  set temp1;\n      call execute('%nrstr(%scdloader(begindate=&begindate,enddate=&enddate,etls_begdate='!!strip(&loopcol)!!',etls_enddate=%unquote(&etls_enddate.),businesskey=&businesskey,generatedkey=&generatedkey,currentind=&currentind,detectchanges=&detectchanges,type1changes=&type1changes,input_table1=&input_table1,output_table1=&output_table1,closeout=&closeout.,loopcol=&loopcol,loopval='!!strip(&loopcol)!!'));');\n      run;\n\n      proc datasets lib = work nolist nowarn memtype = (data view);\n         delete temp1;\n      quit;\n\n   %end;    \n\n%mend scdexec;\n%scdexec( input_table1=&input_table1.\n         ,loopcol=&loopcol.)\n"},"properties":{},"ui":"{\n\t\"showPageContentOnly\": true,\n\t\"pages\": [\n\t\t{\n\t\t\t\"id\": \"inputPage\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"SCD Loader Settings\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"input_table1\",\n\t\t\t\t\t\"type\": \"inputtable\",\n\t\t\t\t\t\"label\": \"Input Table\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"output_table1\",\n\t\t\t\t\t\"type\": \"outputtable\",\n\t\t\t\t\t\"label\": \"Output Table\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"section2\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Business Key\",\n\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"businesskey\",\n\t\t\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\t\t\"label\": \"Select one or more columns to be designated as the business key or natural key:\",\n\t\t\t\t\t\t\t\"table\": \"input_table1\",\n\t\t\t\t\t\t\t\"order\": true,\n\t\t\t\t\t\t\t\"columntype\": \"a\",\n\t\t\t\t\t\t\t\"max\": 20,\n\t\t\t\t\t\t\t\"min\": 1\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"section3\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Generated Key\",\n\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"generatedkey\",\n\t\t\t\t\t\t\t\"type\": \"newcolumn\",\n\t\t\t\t\t\t\t\"label\": \"Generated Key:\",\n\t\t\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\t\t\"hideproperties\": false,\n\t\t\t\t\t\t\t\"readonly\": false\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"section4\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Detect Changes\",\n\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"detectchanges\",\n\t\t\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\t\t\"label\": \"Select columns to be used to detect changes in the target table:\",\n\t\t\t\t\t\t\t\"table\": \"input_table1\",\n\t\t\t\t\t\t\t\"order\": true,\n\t\t\t\t\t\t\t\"columntype\": \"a\",\n\t\t\t\t\t\t\t\"max\": 50,\n\t\t\t\t\t\t\t\"min\": 0\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"section5\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Change Tracking\",\n\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"begindate\",\n\t\t\t\t\t\t\t\"type\": \"newcolumn\",\n\t\t\t\t\t\t\t\"label\": \"Begin Date:\",\n\t\t\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\t\t\"hideproperties\": false,\n\t\t\t\t\t\t\t\"readonly\": false\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"enddate\",\n\t\t\t\t\t\t\t\"type\": \"newcolumn\",\n\t\t\t\t\t\t\t\"label\": \"End Date:\",\n\t\t\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\t\t\"hideproperties\": false,\n\t\t\t\t\t\t\t\"readonly\": false\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"currentind\",\n\t\t\t\t\t\t\t\"type\": \"newcolumn\",\n\t\t\t\t\t\t\t\"label\": \"Current Indicator:\",\n\t\t\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\t\t\"hideproperties\": false,\n\t\t\t\t\t\t\t\"readonly\": false\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"etls_begdate\",\n\t\t\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\t\t\"label\": \"Add expression for Begin Data:\",\n\t\t\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\t\t\"required\": true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"etls_enddate\",\n\t\t\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\t\t\"label\": \"Add expression for End Data:\",\n\t\t\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\t\t\"required\": true\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"section6\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Type 1 Columns\",\n\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"type1changes\",\n\t\t\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\t\t\"label\": \"Select the columns whose values should be overwritten:\",\n\t\t\t\t\t\t\t\"table\": \"input_table1\",\n\t\t\t\t\t\t\t\"order\": true,\n\t\t\t\t\t\t\t\"columntype\": \"a\",\n\t\t\t\t\t\t\t\"max\": 50,\n\t\t\t\t\t\t\t\"min\": 0\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"section7\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Loop Column\",\n\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"loopcol\",\n\t\t\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\t\t\"label\": \"Select the column to loop over (Optional):\",\n\t\t\t\t\t\t\t\"table\": \"input_table1\",\n\t\t\t\t\t\t\t\"order\": true,\n\t\t\t\t\t\t\t\"columntype\": \"n\",\n\t\t\t\t\t\t\t\"max\": 1,\n\t\t\t\t\t\t\t\"min\": 0\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"section8\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Options\",\n\t\t\t\t\t\"open\": true,\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"closeout\",\n\t\t\t\t\t\t\t\"type\": \"dropdown\",\n\t\t\t\t\t\t\t\"label\": \"Close out records not in source table:\",\n\t\t\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"value\": \"Yes\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"value\": \"No\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\t\t\"placeholder\": \"\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"page1\",\n\t\t\t\"label\": \"About\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"text1\",\n\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\"text\": \"The \\\"SCD Loader\\\" Custom Step loads a target table and captures Type 2 as well as Type 1 changes. The SCD Loader is migrated from SAS Data Integration Studio.\\n\\nUSER INTERFACE\\n\\n- Business Key: Select one or more columns to be designated as business key or natural key.\\n\\n- Generated Key: Specify name of generated surrogate key.\\n\\n- Detect Changes: Select columns to be used to detect changes.\\n\\n- Begin Date: Specify name of column to contain begin date.\\n\\n- End Date: Specify name of column to contain end date.\\n\\n- Current Indicator: Specify name of column containing current row indicator.\\n\\n- Add expression for Begin Data: Specify expression for begin datetime for change tracking.\\n\\n- Add expression for End Data: Specify expression for end datetime for change tracking.\\n\\n- Select the columns whose values should be overwritten: Overwrite existing data in target table for specified columns.\\n\\n- Loop Column: Select a date column from the input table used to do sequential updates of the result table (this option is new for this Custom Step, and is used to indicate that you have duplicates on different dates for your business key)\\n\\n- Close out records not in source table: YES if records not in source table should be closed out.\\n\\n- Input Port 1: The source table. This table must not contain duplicates of your business key, unless you have specified a date-column in the Loop Column option.\\n\\n- Output Port 1:  The result table containing the selected columns from the base table and the new columns.\\n\\nVersion 1 (28SEP2022)\\n\\n\\n\\n\\n\\n\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t],\n\t\"syntaxversion\": \"1.3.0\",\n\t\"values\": {\n\t\t\"input_table1\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"output_table1\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"businesskey\": [],\n\t\t\"generatedkey\": {\n\t\t\t\"value\": \"generated_key\",\n\t\t\t\"type\": \"n\",\n\t\t\t\"length\": 8,\n\t\t\t\"format\": \"best32.\"\n\t\t},\n\t\t\"detectchanges\": [],\n\t\t\"begindate\": {\n\t\t\t\"length\": 8,\n\t\t\t\"type\": \"n\",\n\t\t\t\"value\": \"begin_dttm\",\n\t\t\t\"format\": \"datetime.\"\n\t\t},\n\t\t\"enddate\": {\n\t\t\t\"value\": \"end_dttm\",\n\t\t\t\"length\": 8,\n\t\t\t\"format\": \"datetime.\"\n\t\t},\n\t\t\"currentind\": {\n\t\t\t\"value\": \"current_indicator\",\n\t\t\t\"length\": 1\n\t\t},\n\t\t\"etls_begdate\": \"%SYSFUNC(DATETIME())\",\n\t\t\"etls_enddate\": \"'01JAN5999:00:00:00'DT\",\n\t\t\"type1changes\": [],\n\t\t\"loopcol\": [],\n\t\t\"closeout\": {\n\t\t\t\"value\": \"No\"\n\t\t}\n\t}\n}","flowMetadata":{"inputPorts":[{"name":"input_table1","displayName":"input_table1","minEntries":1,"maxEntries":1,"type":"table"}],"outputPorts":[{"name":"output_table1","displayName":"output_table1","description":"","minEntries":1,"maxEntries":1,"columnDelta":{"automaticMapping":[{"inputPort":"input_table1"}],"removeColumnArguments":[],"keepColumnArguments":[],"updateColumnArguments":["generatedkey","begindate","enddate","currentind"]},"type":"table"}]}}
{"creationTimeStamp":"2023-03-15T07:13:49.962Z","modifiedTimeStamp":"2024-01-16T07:49:11.447Z","createdBy":"Remco.Gooijer@sas.com","modifiedBy":"Remco.Gooijer@sas.com","name":"Loop.step","displayName":"Loop.step","localDisplayName":"Loop.step","properties":{},"links":[{"method":"GET","rel":"self","href":"/dataFlows/steps/2e83dbe0-38ed-4af6-9cec-b247de6734ce","uri":"/dataFlows/steps/2e83dbe0-38ed-4af6-9cec-b247de6734ce","type":"application/vnd.sas.data.flow.step"},{"method":"GET","rel":"alternate","href":"/dataFlows/steps/2e83dbe0-38ed-4af6-9cec-b247de6734ce","uri":"/dataFlows/steps/2e83dbe0-38ed-4af6-9cec-b247de6734ce","type":"application/vnd.sas.data.flow.step.summary"},{"method":"GET","rel":"up","href":"/dataFlows/steps","uri":"/dataFlows/steps","type":"application/vnd.sas.collection","itemType":"application/vnd.sas.data.flow.step.summary"},{"method":"PUT","rel":"update","href":"/dataFlows/steps/2e83dbe0-38ed-4af6-9cec-b247de6734ce","uri":"/dataFlows/steps/2e83dbe0-38ed-4af6-9cec-b247de6734ce","type":"application/vnd.sas.data.flow.step","responseType":"application/vnd.sas.data.flow.step"},{"method":"DELETE","rel":"delete","href":"/dataFlows/steps/2e83dbe0-38ed-4af6-9cec-b247de6734ce","uri":"/dataFlows/steps/2e83dbe0-38ed-4af6-9cec-b247de6734ce"},{"method":"GET","rel":"transferExport","href":"/dataFlows/steps/2e83dbe0-38ed-4af6-9cec-b247de6734ce","uri":"/dataFlows/steps/2e83dbe0-38ed-4af6-9cec-b247de6734ce","responseType":"application/vnd.sas.transfer.object"},{"method":"PUT","rel":"transferImportUpdate","href":"/dataFlows/steps/2e83dbe0-38ed-4af6-9cec-b247de6734ce","uri":"/dataFlows/steps/2e83dbe0-38ed-4af6-9cec-b247de6734ce","type":"application/vnd.sas.transfer.object","responseType":"application/vnd.sas.summary"}],"metadataVersion":0.0,"version":2,"type":"code","flowMetadata":{"inputPorts":[{"name":"_input_parameters","displayName":"_input_parameters","localDisplayName":"_input_parameters","minEntries":1,"maxEntries":1,"defaultEntries":0,"type":"table"}],"outputPorts":[{"name":"_output","displayName":"_output","localDisplayName":"_output","minEntries":1,"maxEntries":1,"defaultEntries":0,"type":"table","supportsView":false,"requiresStructure":false}]},"ui":"{\n\t\"showPageContentOnly\": true,\n\t\"pages\": [\n\t\t{\n\t\t\t\"id\": \"page1\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"Data properties\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"_input_parameters\",\n\t\t\t\t\t\"type\": \"inputtable\",\n\t\t\t\t\t\"label\": \"_input_parameters\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"_output\",\n\t\t\t\t\t\"type\": \"outputtable\",\n\t\t\t\t\t\"label\": \"Output table label 1\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"column_variable\",\n\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\"label\": \"Select macro variable column\",\n\t\t\t\t\t\"order\": false,\n\t\t\t\t\t\"columntype\": \"c\",\n\t\t\t\t\t\"max\": 1,\n\t\t\t\t\t\"min\": 1,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"table\": \"_input_parameters\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"column_value\",\n\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\"label\": \"Select value column\",\n\t\t\t\t\t\"order\": false,\n\t\t\t\t\t\"columntype\": \"a\",\n\t\t\t\t\t\"max\": 1,\n\t\t\t\t\t\"min\": 1,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"table\": \"_input_parameters\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"_jobname\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Specify the job definition name (Case sensitive!)\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"page3\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"Scheduling properties\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"concurrent_jobs\",\n\t\t\t\t\t\"type\": \"numstepper\",\n\t\t\t\t\t\"label\": \"Number of concurrent jobs\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"integer\": true,\n\t\t\t\t\t\"min\": 0,\n\t\t\t\t\t\"max\": 25,\n\t\t\t\t\t\"stepsize\": 1\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"wait_for_processes\",\n\t\t\t\t\t\"type\": \"checkbox\",\n\t\t\t\t\t\"label\": \"Wait for processes to finish\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"_delayed\",\n\t\t\t\t\t\"type\": \"checkbox\",\n\t\t\t\t\t\"label\": \"Delayed execution\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"_delayedseconds\",\n\t\t\t\t\t\"type\": \"numstepper\",\n\t\t\t\t\t\"label\": \"Delayed seconds:\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"integer\": true,\n\t\t\t\t\t\"min\": 1,\n\t\t\t\t\t\"max\": 5,\n\t\t\t\t\t\"stepsize\": 1,\n\t\t\t\t\t\"enabled\": \"$_delayed\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"page2\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"Description\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"text2\",\n\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\"text\": \"This custom step executes, in parallel, one deployed flow for a given set of parameters. \\nFor that to work it needs:\\n\\n- A dataset with two columns, parameter and value. Parameter contains the macro variable and value contains the value for the specified macro variable.\\n- The name of the deployed flow.\\n\\nImportant to know:\\n- Currently the loop custom step accepts only one macro variable with its corresponding values.\\n- The output of this custom step is the status table, also used internally.\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t],\n\t\"syntaxversion\": \"1.3.0\",\n\t\"values\": {\n\t\t\"_input_parameters\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"_output\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"column_variable\": [],\n\t\t\"column_value\": [],\n\t\t\"_jobname\": \"\",\n\t\t\"concurrent_jobs\": 4,\n\t\t\"wait_for_processes\": true,\n\t\t\"_delayed\": false,\n\t\t\"_delayedseconds\": 1\n\t}\n}","templates":{"SAS":"/*\n\tInitialize the variables.\n*/\n%let nbr_job_rows = 0;\n%let nbr_parameter_rows = 0;\n%let nbr_rows = 0;\n%let job_uri =;\n\n/*\n\tInput for the input table validation.\n\tCount the number of rows. This number needs to be bigger then 0.\n*/\ndata _NULL_;\n\tset \n\t\t&_input_parameters end=last;\n\tif last then call symputx(\"nbr_parameter_rows\", _n_);\nrun;\n\n%macro get_job_uri\n(\n\tjob_name=\t\n);\n\tdata _null_; \n\t\tcall symputx('viyaHost', reverse(substr(substr(reverse(\"&_BASEURL.\"), 2), find(substr(reverse(\"&_BASEURL.\"), 2), '/') + 1)));\n\trun;\n\n\t/*\n\t\tSetup and execute the http request.\n\t*/\n\tfilename joburi temp;\n\tproc http\n\t\turl = \"&viyahost./jobExecution/jobRequests\"\n\t\tout= joburi\n\t\tmethod='get'\n\t\t\toauth_bearer = sas_services\n\t\t\t%if &_jobname ne %then %do;\n\t\t\t\tquery= ('filter' = \"contains('name', '&_jobname')\");\n\t\t\t%end;\n\t\t\t%else %do;\n\t\t\t\t;\n\t\t\t%end;\n\t\theaders\n\t\t\t'Accept'= 'application/vnd.sas.collection+json';\n\trun;\t\n\n\t/*\n\t\tProcess the response file, if it exists.\n\t*/\n\t%if %sysfunc(fexist(joburi)) %then %do;\n\n\t\tlibname joburi json;\n\t\t/*\n\t\t\tCheck that the items table exists.\n\t\t*/\n\t\t%if %sysfunc(exist(joburi.items)) %then %do;\n\t\t\t/*\n\t\t\t\tSelect the jobs for which the URI exists.\n\t\t\t*/\n\t\t\tdata job_uri;\n\t\t\t\tset joburi.items\n\t\t\t\t(\n\t\t\t\t\tkeep = \n\t\t\t\t\t\tname \n\t\t\t\t\t\tjobDefinitionUri \n\t\t\t\t\twhere = \n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tjobDefinitionUri ~= ''\n\t\t\t\t\t\t)\n\t\t\t\t);\n\t\t\trun;\n\t\t\tlibname joburi;\n\t\t%end;\n\t\t%else %do;\n\t\t\t%put ERROR: The items table in the response file does not exist. Aborting process.;\n\t\t\t%abort;\n\t\t%end;\n\t%end;\n\t%else %do;\n\t\t%put ERROR: The response file does not exist. Aborting process.;\n\t\t%abort;\n\t%end;\n\n\t/*\n\t\tAssign the job uri to the 'job_uri' macro variable.\n\t*/\n\t%if %sysfunc(exist(work.job_uri)) %then %do;\n\n\t\t/*\n\t\t\tCount the number of jobs returned.\n\n\t\t\tOnly continue in case the numbers equals to 1.\n\t\t*/\n\t\tproc sql noprint;\n\t\t\tselect \n\t\t\t\tcount(*) into :nbr_job_rows \n\t\t\tfrom \n\t\t\t\twork.job_uri;\n\t\tquit;\n\n\t\t%if &nbr_job_rows NE 1 %then %do;\n\t\t\t%put ERROR: 0 of more then 1 job encountered with name &_jobname. Aborting process.;\n\t\t\t%abort;\n\t\t%end;\n\t\t%else %do;\n\t\t\tdata _null_;\n\t\t\t\tset\n\t\t\t\t\twork.job_uri;\n\t\t\t\tcall symputx(\"job_uri\", strip(jobDefinitionUri));\n\t\t\trun;\t\t\n\t\t%end;\n\t%end;\n\t%else %do;\n\t\t%put ERROR: job_uri table does not exist. Aborting process.;\n\t\t%abort;\n\t%end;\n%mend;\n%get_job_uri\n(\n\tjob_name = &_jobname\n);\n\n/*\n\tOnly start the process in case:\n\t1. The parameter table contains more than 0 rows.\n*/\n%if &nbr_parameter_rows eq 0 %then %do;\n\t%put ERROR: Not enough parameters to run the loop step. Aborting process.;\n\t%abort;\n%end;\n%else %do;\n\t/*\n\t\tThe number of rows in the input table check out. Continue to run the process.\n\t*/\n\tdata _null_; \n\t\tcall symputx('viyaHost', reverse(substr(substr(reverse(\"&_BASEURL.\"), 2), find(substr(reverse(\"&_BASEURL.\"), 2), '/') + 1)));\n\trun;\n\n\t/*\n\t\tCreate the status tables that will hold all execution statuses for all executed job requests.\n\t\tBased on this table you can create a polling mechanism to validate that each process has finished successfully.\n\t*/\n\tdata &_output;\n\t\tattrib id length=$36.;\n\t\tattrib name length=$128.;\n\t\tattrib state length=$32.;\n\t\tattrib start_dttm length=8 format=datetime22.3;\n\t\tattrib end_dttm length=8 format=datetime22.3;\n\t\tstop;\n\trun; \n\n\t%macro exec_job\n\t(\n\t\tjob_uri=,\n\t\tparameter=,\n\t\tvalue=\n\t);\n\n\t\t%if %unquote(%str(%')&job_uri%str(%')) ne '' %then %do;\n\n\t\t\t/*\n\t\t\t\tIn case the user asked for a delayed execution...\n\t\t\t*/\t\t\n\t\t\t%if &_delayed eq 1 %then %do;\n\t\t\t\t%put NOTE: Delayed executing, waiting for &_delayedseconds seconds.;\n\t\t\t\tdata _null_;\n\t\t\t\t\tsleeping = sleep(&_delayedseconds, 1);\n\t\t\t\trun;\n\t\t\t%end;\n\n\t\t\t/*\n\t\t\t\tCreate the JSON request file.\n\t\t\t*/\n\t\t\t%let process_name = Flow instance. (&parameter: &value);\n\t\t\tfilename request temp;\n\t\t\tproc json out=request nosastags;\n\t\t\t\twrite open object;\n\t\t\t\t/*\n\t\t\t\t\tShow the instance of the flow in the monitoring section of the environment manager.\n\t\t\t\t*/\n\t\t\t\twrite values \"name\" \"&process_name\";\n\t\t\t\twrite values \"jobDefinitionUri\" \"&job_uri\";\n\t\t\t\t/*\n\t\t\t\t\tOnly specify arguments if there are parameters/arguments to begin with.\n\t\t\t\t*/\n\t\t\t\t%if &parameter ne %then %do;\n\t\t\t\t\twrite values \"arguments\";\n\t\t\t\t\twrite open object;\n\t\t\t\t\t\twrite values \"&parameter\" \"&value\";\n\t\t\t\t\twrite close;\n\t\t\t\t%end;\n\t\t\t\twrite close;\n\t\t\trun;\n\n\t\t\t/*\n\t\t\t\tSetup and execute the HTTP request.\n\t\t\t*/\n\t\t\tfilename response temp;\n\t\t\tproc http\n\t\t\t\turl = \"&viyahost./jobExecution/jobs?submitter=workflow\"\n\t\t\t\tin = request\n\t\t\t\tout= response\n\t\t\t\tmethod='post'\n\t\t\t\t\toauth_bearer = sas_services;\n\t\t\t\theaders\n\t\t\t\t\t'Content-Type'='application/vnd.sas.job.execution.job.request+json'\n\t\t\t\t\t'Accept'='application/vnd.sas.job.execution.job+json';\n\t\t\trun;\n\n\t\t\t%if %sysfunc(fexist(response)) %then %do;\n\n\t\t\t\t/*\n\t\t\t\t\tAdd the state, should be 'running', of the current job to the execute_status table.\n\t\t\t\t\n\t\t\t\t\tNote that the column specification can differ. This will cause warnings during the PROC APPEND step.\n\t\t\t\t\tThat is why the resulting table firstly needs to be created based on the internally defined status table.\n\t\t\t\t*/\n\t\t\t\tlibname resp json fileref=response;\n\t\t\t\tdata work.root(drop=creationTimeStamp);\n\t\t\t\t\tattrib name length=$128.;\n\t\t\t\t\tattrib end_dttm length=8 format=datetime22.3;\t\n\t\t\t\t\tattrib start_dttm length=8 format=datetime22.3;\n\t\t\t\t\tset \n\t\t\t\t\t\t&_output(obs=0)\n\t\t\t\t\t\tresp.root(keep=id state creationTimeStamp);\n\t\t\t\t\tstart_dttm = input(creationTimeStamp, E8601DZ.);\n\t\t\t\t\tname = \"&process_name\";\n\t\t\t\trun;\n\t\t\t\tproc append data=work.root base=&_output force; run;\n\t\t\t\tlibname resp;\n\t\t\t%end;\n\t\t\t%else %do;\n\t\t\t\t%put ERROR: The response file does not exist. Aborting process.;\n\t\t\t\t%abort;\t\t\t\t\t\t\t\n\t\t\t%end;\n\t\t%end;\n\t\t%else %do;\n\t\t\t%put ERROR: No URI provided. Aborting process.;\n\t\t\t%abort;\n\t\t%end;\n\t%mend;\n\n\t/*\n\t\tCreate the input dataset for the exec_job macro.\n\t*/\n\tproc sql noprint;\n\t\tcreate table work.input as\n\t\t\tselect\n\t\t\t\t\"&job_uri\" as URI,\n\t\t\t\t&column_variable as VAR,\n\t\t\t\t&column_value as VALUE\n\t\t\tfrom\n\t\t\t\t&_input_parameters;\n\tquit;\n\n\t%macro update_status\n\t(\n\t\tId=\n\t);\n\t\t/*\n\t\t\tThis process only makes sense when the execute_status table exists.\n\t\t*/\n\t\t%if %sysfunc(exist(&_output, data)) %then %do;\n\t\t\t/*\n\t\t\t\tSetup and execute the HTTP request.\n\t\t\t*/\n\t\t\tfilename response temp;\n\t\t\tproc http\n\t\t\t\turl=\"&viyahost./jobExecution/jobs/&Id\"\n\t\t\t\tout=response\n\t\t\t\tmethod=\"get\"\n\t\t\t\t\toauth_bearer = sas_services;\n\t\t\t\theaders\n\t\t\t\t\t'Accept'='application/json';\n\t\t\trun;\n\n\t\t\t%if %sysfunc(fexist(response)) %then %do;\n\t\t\t\tlibname status json fileref=response;\n\n\t\t\t\t/*\n\t\t\t\t\tUpdate the output table with the values from the REST API.\n\t\t\t\t\tNote that the root table will always contain one row.\n\t\t\t\t*/\n\t\t\t\tproc sql noprint;\n\t\t\t\t\tupdate \n\t\t\t\t\t\t&_output\n\t\t\t\t\tset \t\n\t\t\t\t\t\tstate = \n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tselect \n\t\t\t\t\t\t\t\t\tstrip(state) \n\t\t\t\t\t\t\t\tfrom \n\t\t\t\t\t\t\t\t\tstatus.root\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\tend_dttm = \n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tselect \n\t\t\t\t\t\t\t\t\tinput(modifiedTimeStamp, E8601DZ.)\n\t\t\t\t\t\t\t\tfrom\n\t\t\t\t\t\t\t\t\tstatus.root\n\t\t\t\t\t\t\t)\n\t\t\t\t\twhere\n\t\t\t\t\t\tid = \"&id\";\n\t\t\t\tquit;\n\t\t\t\tlibname status clear;\n\t\t\t%end;\n\t\t\t%else %do;\n\t\t\t\t%put ERROR: Unable to update the status table. No response file encountered.;\n\t\t\t%end;\n\t\t%end;\n\t\t%else %do;\n\t\t\t%put ERROR: The status table, &_output, does not exist.;\n\t\t\t%abort;\n\t\t%end;\n\t%mend;\n\n\t%macro exec_jobs;\n\t\t/*\n\t\t\tLoad input table into memory.\n\t\t*/\n\t\tdata _null_;\n\t\t\tset work.input end=last;\n\t\t\tcall symputx('URI'||strip(put(_n_, 8.)), URI);\n\t\t\tcall symputx('VAR'||strip(put(_n_, 8.)), VAR);\n\t\t\tcall symputx('VALUE'||strip(put(_n_, 8.)), VALUE);\n\t\t\tif last then call symputx('nbr_jobs', _n_);        \n\t\trun;\n\t\t%put NOTE: Initial number of jobs in queue: &nbr_jobs.;\n\n\t\t/*\n\t\t\tInitialize macro variables.\n\t\t*/\n\t\t%let index = 1;\n\t\t%let running_jobs = 0;\n\t\t%do %while (&index le &nbr_jobs);\n\n\t\t\t/*\n\t\t\t\tCheck for the number running jobs, to be less or equal to\n\t\t\t\tthe number of concurrent jobs.\n\t\t\t*/\n\t\t\tdata _null_;\n\t\t\t\tset &_output(where=(state='running')) end=last;\n\t\t\t\tif last then call symput(\"running_jobs\", _n_);\n\t\t\trun;\n\t\t\t%put NOTE: Number of running jobs: &running_jobs;\n\t\t\t\n\t\t\t/*\n\t\t\t\tIf the number of running jobs is less then the amount of jobs allowed to run concurrenly,\n\t\t\t\tstart a job and register it in the status table.\n\t\t\t*/\n\t\t\t%if (&running_jobs lt &concurrent_jobs) %then %do;\n\t\t\t\t%put NOTE: Adding new job from the queue;\n\t\t\t\t%exec_job(\n\t\t\t\t\tjob_uri = &&uri&index,\n\t\t\t\t\tparameter = &&var&index,\n\t\t\t\t\tvalue = &&value&index\n\t\t\t\t);\n\t\t\t\t/*\n\t\t\t\t\tincrement the index parameter, ready to start the next job. \n\t\t\t\t*/\n\t\t\t\t%let index = %eval(&index + 1);\t\n\t\t\t%end;\n\n\t\t\t/*\n\t\t\t\tOnly update the status of jobs with state 'running'.\n\t\t\t*/\n\t\t\tdata _null_;\n\t\t\t\tset\n\t\t\t\t\t&_output(where=(state='running'));\n\n\t\t\t\tcall execute(\n\t\t\t\t\tcats(\n\t\t\t\t\t\t'%update_status(Id= %STR(',\n\t\t\t\t\t\tSTRIP(id),\n\t\t\t\t\t\t'))'\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\trun;\n\t\t\t/*\n\t\t\t\tWait 1/2 second for the next iteration.\n\n\t\t\t\tThis will keep the log file size down.\n\t\t\t*/\n\t\t\tdata _null_;\n\t\t\t\tslept = sleep(.50, 1);\n\t\t\trun;\n\t\t%end;\n\t%mend;\n\t%exec_jobs;\t\n%end;\n\n/*\n\tThe folllwing section is there to wait for the processes, just started, to be finished before continuing\n\twith the next (custom) step.\n*/\n%if &wait_for_processes %then %do;\n\n\t%macro check_for_completion;\n\t\t/*\n\t\t\tUpdate for all processes the status and determain if all processes have finished.\n\t\t*/\n\t\t%if %sysfunc(exist(&_output, data)) %then %do;\n\t\t\t%let still_running = -1;\n\t\t\t%let wait_cycles = 0;\n\n\t\t\t%do %while (&still_running ne 0);\n\t\t\t\t/*\n\t\t\t\t\tUpdate the status for all running jobs.\n\t\t\t\t*/\n\t\t\t\tdata _null_;\n\t\t\t\t\tset\n\t\t\t\t\t\t&_output\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\twhere=(upcase(state) = 'RUNNING')\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tcall execute\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tcats\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t'%update_status(Id= %STR(',\n\t\t\t\t\t\t\t\tSTRIP(id),\n\t\t\t\t\t\t\t\t'))'\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\trun;\n\t\t\n\t\t\t\t/*\n\t\t\t\t\tCount the number of jobs that are running.\n\t\t\t\t*/\n\t\t\t\tproc sql noprint;\n\t\t\t\t\tselect \n\t\t\t\t\t\tcount(*) into :still_running \n\t\t\t\t\tfrom \n\t\t\t\t\t\t&_output \n\t\t\t\t\twhere \n\t\t\t\t\t\tupcase(state) = 'RUNNING';\n\t\t\t\tquit;\n\t\t\t\t%put NOTE: Number of jobs that are running: &still_running;\n\t\t\n\t\t\t\t/*\n\t\t\t\t\tSleep for one second before checking for completion again.\n\t\t\t\t*/\n\t\t\t\tdata _null_;\n\t\t\t\t\tslept = sleep(1, 1);\n\t\t\t\trun;\n\t\t\t\t%let wait_cycles = %eval(&wait_cycles + 1);\n\t\t\t%end;\n\t\t\t%put NOTE: Total number of wait cycles of 1 second: &wait_cycles;\n\t\t%end;\n\t\t%else %do;\n\t\t\t%put ERROR: The table status table, &_output, does not exist.;\n\t\t\t%abort;\n\t\t%end;\n\t%mend;\n\t\n\t%check_for_completion;\n%end;"}}
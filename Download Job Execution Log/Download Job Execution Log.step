{"creationTimeStamp":"2024-06-14T18:33:07.863Z","modifiedTimeStamp":"2024-11-03T13:35:43.105Z","createdBy":"Ethan.Kavanaugh@sas.com","modifiedBy":"Remco.Gooijer@sas.com","name":"Download Job Execution Log.step","displayName":"Download Job Execution Log.step","localDisplayName":"Download Job Execution Log.step","properties":{},"links":[{"method":"GET","rel":"self","href":"/dataFlows/steps/60d31e77-5df6-4f14-bfed-55bc8f8e2824","uri":"/dataFlows/steps/60d31e77-5df6-4f14-bfed-55bc8f8e2824","type":"application/vnd.sas.data.flow.step"},{"method":"GET","rel":"alternate","href":"/dataFlows/steps/60d31e77-5df6-4f14-bfed-55bc8f8e2824","uri":"/dataFlows/steps/60d31e77-5df6-4f14-bfed-55bc8f8e2824","type":"application/vnd.sas.data.flow.step.summary"},{"method":"GET","rel":"up","href":"/dataFlows/steps","uri":"/dataFlows/steps","type":"application/vnd.sas.collection","itemType":"application/vnd.sas.data.flow.step.summary"},{"method":"PUT","rel":"update","href":"/dataFlows/steps/60d31e77-5df6-4f14-bfed-55bc8f8e2824","uri":"/dataFlows/steps/60d31e77-5df6-4f14-bfed-55bc8f8e2824","type":"application/vnd.sas.data.flow.step","responseType":"application/vnd.sas.data.flow.step"},{"method":"DELETE","rel":"delete","href":"/dataFlows/steps/60d31e77-5df6-4f14-bfed-55bc8f8e2824","uri":"/dataFlows/steps/60d31e77-5df6-4f14-bfed-55bc8f8e2824"},{"method":"POST","rel":"copy","href":"/dataFlows/steps/60d31e77-5df6-4f14-bfed-55bc8f8e2824/copy","uri":"/dataFlows/steps/60d31e77-5df6-4f14-bfed-55bc8f8e2824/copy","responseType":"application/vnd.sas.data.flow.step"},{"method":"GET","rel":"transferExport","href":"/dataFlows/steps/60d31e77-5df6-4f14-bfed-55bc8f8e2824","uri":"/dataFlows/steps/60d31e77-5df6-4f14-bfed-55bc8f8e2824","responseType":"application/vnd.sas.transfer.object"},{"method":"PUT","rel":"transferImportUpdate","href":"/dataFlows/steps/60d31e77-5df6-4f14-bfed-55bc8f8e2824","uri":"/dataFlows/steps/60d31e77-5df6-4f14-bfed-55bc8f8e2824","type":"application/vnd.sas.transfer.object","responseType":"application/vnd.sas.summary"}],"metadataVersion":0.0,"version":2,"type":"code","flowMetadata":{"inputPorts":[{"name":"_inputTable","displayName":"_inputTable","localDisplayName":"_inputTable","minEntries":1,"maxEntries":1,"defaultEntries":0,"type":"table"}],"outputPorts":[{"name":"_output","displayName":"_output","localDisplayName":"_output","minEntries":1,"maxEntries":1,"defaultEntries":0,"type":"table","supportsView":false,"requiresStructure":false}]},"ui":"{\n\t\"showPageContentOnly\": true,\n\t\"pages\": [\n\t\t{\n\t\t\t\"id\": \"page1\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"Properties\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"_inputTable\",\n\t\t\t\t\t\"type\": \"inputtable\",\n\t\t\t\t\t\"label\": \"Input table:\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"_output\",\n\t\t\t\t\t\"type\": \"outputtable\",\n\t\t\t\t\t\"label\": \"Output table:\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"_idColumn\",\n\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\"label\": \"Select the column containing the job execution id:\",\n\t\t\t\t\t\"order\": false,\n\t\t\t\t\t\"columntype\": \"a\",\n\t\t\t\t\t\"max\": 1,\n\t\t\t\t\t\"min\": 1,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"table\": \"_inputTable\",\n\t\t\t\t\t\"include\": null\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"_targetlocation\",\n\t\t\t\t\t\"type\": \"path\",\n\t\t\t\t\t\"label\": \"Select the SAS Compute file system directory:\",\n\t\t\t\t\t\"pathtype\": \"folder\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"page2\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"About\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"text2\",\n\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\"text\": \"Download Job Execution Log custom step\\n=============================\\n\\nThis custom step enables you to download the log file for a job execution, and store it as a physical file in a user-defined physical location on the file system of the SAS Viya Compute server, based on a Job execution Id.\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"section1\",\n\t\t\t\t\t\"type\": \"section\",\n\t\t\t\t\t\"label\": \"Changelog\",\n\t\t\t\t\t\"open\": false,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"children\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": \"text1\",\n\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\"text\": \"* Version 1.2 (03NOV2024)\\n  - Published extrnally\\n\\n* Version 1.1 (09MAY2024)\\n  - Published internally \\n  - Taken the feedback messages from the API response JSON file, when available and/or applicable.\\n\\n* Version 1,0 (08MAY2023)\\n  - Published internally\\n  - Initial version\\n\\n\",\n\t\t\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t],\n\t\"syntaxversion\": \"1.3.0\",\n\t\"values\": {\n\t\t\"_inputTable\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"_output\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"_idColumn\": [],\n\t\t\"_targetlocation\": \"\"\n\t}\n}","templates":{"SAS":"\n/*\n\tExtract the server type for server type checking.\n*/\ndata _null_;\n\tcall symputx(\"_serverType\", strip(scan(\"&_targetlocation\", 1, ':')));\nrun;\n%put &=_serverType;\n\ndata _null_;\n\tcall symputx(\"_targetdirectory\", strip(scan(\"&_targetlocation\", 2, ':')));\nrun;\n%put NOTE: _targetdirectory: &_targetdirectory;\n\n%let viyaHost =;\ndata _null_; \n\tcall symputx('viyaHost', reverse(substr(substr(reverse(\"&_BASEURL.\"), 2), find(substr(reverse(\"&_BASEURL.\"), 2), '/') + 1)));\nrun;\n%put NOTE: viyaHost: &viyaHost;\n\n/*\n\tCreate for each Id a macro variable, to be used in the loop that calls the 'GetJobExecutionLog' macro. \n*/\n%let nbr_ids = 0;\ndata _null_;\n\tset \n\t\t&_inputTable end=last;\n\tcall symputx('Id'||strip(put(_N_, 8.)), &_idColumn);\n\tif last then call symputx('nbr_ids', _N_);        \nrun;\n%put NOTE: nbr_ids: &nbr_ids;\n\n/*\n\tCreate the output table.\n*/\ndata &_output;\n\tattrib JobExecutionId length=$36.;\n\tattrib logFile length=$256.;\n\tattrib message length=$256.;\n\tstop;\nrun;\n\n%let is_valid_json = 0;\n%macro is_json_file(file_path);\n\t%local \n\t\tfile_ref \n\t\tfirstchar;\n\n\t/* \n\t\tOpen the file and read the first character.\n\t\tIf that character is a '{', then we assume that the file is a json file.\n\t*/\n\tfilename file_ref \"&file_path\";\n\tdata _null_;\n\t\tinfile \n\t\t\tfile_ref \n\t\t\tfirstobs=1 \n\t\t\tobs=1 \n\t\t\ttruncover;\n\t\t\n\t\tinput @1 firstchar $1.;\n\t\tif firstchar = '{' then \n\t\t\tcall symputx(\"is_valid_json\", 1);\n\trun;\n\tfilename file_ref clear;\n%mend is_json_file;\n\n%macro GetJobExecutionLog\n(\n\tjobExecutionId=\n);\n\n\t/*\n\t\tInitialize the following macro variables to be empty of 0.\n\t*/\n\t%let message =;\n\t%let is_valid_json = 0;\n\t\n\t/*\n\t\tSetup and execute the initial job execution information request from the specified endpoint.\n\t*/\n\tfilename response temp;\n\tproc http\n\t\turl=\"&viyaHost./jobExecution/jobs/&jobExecutionId\"\n\t\tout=response\n\t\tmethod=\"get\"\n\t\t\toauth_bearer = sas_services;\t\n\t\theaders\n\t\t\t'Accept'='application/json';\n\trun;\n\t\n\t/*\n\t\tValidate the we've received a response file and that the root- and jobrequest tables exist within the response file.\n\t*/\n\t%if %sysfunc(fexist(response)) %then %do;\n\t\tlibname resp json fileref=response;\n\t\t%if %sysfunc(exist(resp.root)) and %sysfunc(exist(resp.jobrequest)) %then %do;\n\n\t\t\t/*\n\t\t\t\tbefore trying to use the column 'logLocation', verify that it exists.\n\t\t\t*/\n\t\t\t%let columnExists = 0;\n\t\t\t%let dsid = %sysfunc(open(resp.root));\n\t\t\t%let columnExists = %sysfunc(varnum(&dsid, loglocation));\n\t\t\t%let rc = %sysfunc(close(&dsid));\n\n\t\t\t%if &columnExists > 0 %then %do;\n\n\t\t\t\t/*\n\t\t\t\t\tRetrieve the log file information from the response file.\n\t\t\t\t*/\n\t\t\t\t%let loglocation=;\n\t\t\t\tproc sql noprint;\n\t\t\t\t\tselect logLocation into :loglocation from resp.root;\n\t\t\t\tquit;\n\t\t\t\t%put NOTE: loglocation: &loglocation;\n\t\t\t\n\t\t\t\t/*\n\t\t\t\t\tThe column 'name' in the jobrequest table is not always available...\n\t\t\t\t*/\n\t\t\t\t%let columnExists = 0;\n\t\t\t\t%let dsid = %sysfunc(open(resp.jobrequest));\n\t\t\t\t%let columnExists = %sysfunc(varnum(&dsid, name));\n\t\t\t\t%let rc = %sysfunc(close(&dsid));\n\n\t\t\t\t%let logname =;\n\t\t\t\t%if &columnExists > 0 %then %do;\t\n\t\t\t\t\t/*\n\t\t\t\t\t\tCreate the logfile name, based on the convention used by the 'log file download' functionality used by the \n\t\t\t\t\t\tenvironment manager.\n\t\t\t\t\t*/\t\n\n\t\t\t\t\tproc sql noprint;\n\t\t\t\t\t\tselect \n\t\t\t\t\t\t\tstrip(tranwrd(j.name, \"/\", \"|\")) || '_' || strip(r.createdBy) || '_' || strip(r.creationTimeStamp) || '.log' into :logname\n\t\t\t\t\t\tfrom\n\t\t\t\t\t\t\tresp.root as r inner join resp.jobrequest as j on r.ordinal_root = j.ordinal_root;\t\n\t\t\t\t\tquit;\n\t\t\t\t%end;\n\t\t\t\t%else %do;\n\t\t\t\t\t/*\n\t\t\t\t\t\tThe name column doesn't exist, give it a default name.\n\t\t\t\t\t*/\n\n\t\t\t\t\tproc sql noprint;\n\t\t\t\t\t\tselect \n\t\t\t\t\t\t\t'Unknown name' || '_' || strip(r.createdBy) || '_' || strip(r.creationTimeStamp) || '.log' into :logname\n\t\t\t\t\t\tfrom\n\t\t\t\t\t\t\tresp.root as r;\t\n\t\t\t\t\tquit;\n\t\t\t\t%end;\n\t\t\t\t\n\t\t\t\t%let logname = %str(&logname);\n\t\t\t\t%put NOTE: logname: &logname;\n\t\t\t\t/*\n\t\t\t\t\tSetup the request for the log file and execute it.\n\t\t\t\t*/\n\t\t\t\tfilename log temp;\n\t\t\t\tproc http\n\t\t\t\t\turl=\"&viyaHost./&loglocation./content\"\n\t\t\t\t\tout=log\n\t\t\t\t\tmethod=\"get\"\n\t\t\t\t\t\toauth_bearer = sas_services;\t\n\t\t\t\t\theaders\n\t\t\t\t\t\t'Accept'='application/json';\n\t\t\t\trun;\n\t\t\t\t/*\n\t\t\t\t\tValidate that we've recieved the log response file from the system.\n\t\t\t\t*/\n\t\t\t\t%if %sysfunc(fexist(log)) %then %do;\n\n\t\t\t\t\t/*\n\t\t\t\t\t\tValidate that the response file really is a json file.\n\t\t\t\t\t*/\n\t\t\t\t\t%let file_location = %sysfunc(pathname(log, fileref));\n\t\t\t\t\t%is_json_file(&file_location);\n\t\t\t\t\t%put is_valid_json: &is_valid_json;\n\t\t\t\t\t\t\n\t\t\t\t\t%if &is_valid_json eq 1 %then %do;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tThe returned file really is a proper json file.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tlibname log json fileref=log;\n\t\t\t\t\t\t%if %sysfunc(exist(log.items)) %then %do;\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tWrite the line column, from the items table, to a physical file.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tdata _null_;\n\t\t\t\t\t\t\t\tset \n\t\t\t\t\t\t\t\t\tlog.items(keep=line);\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t\tThe resulting log file is written to the specified location and \n\t\t\t\t\t\t\t\t\thas the defined file name.\n\t\t\t\t\t\t\t\t*/\t\n\t\t\t\t\t\t\t\tfile \n\t\t\t\t\t\t\t\t\t\"&_targetdirectory./&logname\";\n\t\t\t\t\t\t\t\tput (_all_) (+0);\n\t\t\t\t\t\t\trun;\n\t\t\t\t\t\t\tdata success;\n\t\t\t\t\t\t\t\tattrib JobExecutionId length=$36.;\n\t\t\t\t\t\t\t\tattrib logFile length=$256.;\n\t\t\t\t\t\t\t\tattrib message length=$256.;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tJobExecutionId = \"&jobExecutionId\";\n\t\t\t\t\t\t\t\tlogFile = \"&_targetdirectory./&logname\";\n\t\t\t\t\t\t\t\tmessage = \"\";\n\t\t\t\t\t\t\t\toutput;\n\t\t\t\t\t\t\trun;\n\t\t\t\t\t\t\tproc append base=&_output data=work.success force; run;\n\t\t\t\t\t\t%end;\n\t\t\t\t\t\t%else %do;\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tWe have a log response file, which is also a json file, but is doesn't have the \n\t\t\t\t\t\t\t\titems table included...\n\n\t\t\t\t\t\t\t\tLets have a look for the message column and give that back as feedback to the user.\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t%let columnExists = 0;\n\t\t\t\t\t\t\t%let dsid = %sysfunc(open(log.root));\n\t\t\t\t\t\t\t%let columnExists = %sysfunc(varnum(&dsid, message));\n\t\t\t\t\t\t\t%let rc = %sysfunc(close(&dsid));\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t%if &columnExists > 0 %then %do;\n\t\t\t\t\t\t\t\tproc sql noprint;\n\t\t\t\t\t\t\t\t\tselect\n\t\t\t\t\t\t\t\t\t\tmessage into :message\n\t\t\t\t\t\t\t\t\tfrom\n\t\t\t\t\t\t\t\t\t\tlog.root;\n\t\t\t\t\t\t\t\tquit;\n\t\t\t\t\t\t\t%end;\n\t\t\t\t\t\t\t%else %do;\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t\tIf everything failse...\n\t\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t\t%let message = ERROR: The items table does not exist for the log response file.;\n\t\t\t\t\t\t\t%end;\n\t\t\t\t\t\t%end;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tClear the libary reference, if it exists.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t%if %sysfunc(libref(log)) EQ 0 %then %do;\n\t\t\t\t\t\t\tlibname log clear;\n\t\t\t\t\t\t%end;\n\t\t\t\t\t%end;\n\t\t\t\t\t%else %do;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tThe returned response file is not a JSON file. For now I've decided to copy that file with the specified \n\t\t\t\t\t\t\tnaming convention to the target directory.\n\n\t\t\t\t\t\t\tNote that the log reference is defined as temp and will be remove automatically.\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t%let target_file_name = %bquote(&_targetdirectory./&logname);\n\t\t\t\t\t\tfilename targetf \"&target_file_name\";\n\t\t\t\t\t\tdata _null_;\n\t\t\t\t\t\t\trc = fcopy('log', 'targetf');\n\t\t\t\t\t\trun;\n\t\t\t\t\t\tdata success;\n\t\t\t\t\t\t\tattrib JobExecutionId length=$36.;\n\t\t\t\t\t\t\tattrib logFile length=$256.;\n\t\t\t\t\t\t\tattrib message length=$256.;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tJobExecutionId = \"&jobExecutionId\";\n\t\t\t\t\t\t\tlogFile = \"&target_file_name\";\n\t\t\t\t\t\t\tmessage = \"&message\";\n\t\t\t\t\t\t\toutput;\n\t\t\t\t\t\trun;\n\t\t\t\t\t\tproc append base=&_output data=work.success force; run;\n\t\t\t\t\t%end;\n\t\t\t\t%end;\n\t\t\t\t%else %do;\n\t\t\t\t\t%let message = ERROR: No log response file received.;\n\t\t\t\t%end;\n\t\t\t%end;\n\t\t\t%else %do;\n\t\t\t\t%let message = ERROR: The column 'logLocation' doesn not exist, in the initial response file. Unable to retrieve the log file.;\n\t\t\t%end;\n\t\t%end;\n\t\t%else %do;\n\t\t\t/*\n\t\t\t\tWe have a response file, but no jobrequest table....\n\n\t\t\t\tLets have a look for the message column and give that back as feedback to the user.\t\n\t\t\t*/\n\t\t\t%let columnExists = 0;\n\t\t\t%let dsid = %sysfunc(open(resp.root));\n\t\t\t%let columnExists = %sysfunc(varnum(&dsid, message));\n\t\t\t%let rc = %sysfunc(close(&dsid));\n\t\t\t\t\t\t\t\n\t\t\t%if &columnExists > 0 %then %do;\n\t\t\t\tproc sql noprint;\n\t\t\t\t\tselect\n\t\t\t\t\t\tmessage into :message\n\t\t\t\t\tfrom\n\t\t\t\t\t\tresp.root;\n\t\t\t\tquit;\n\t\t\t%end;\n\t\t\t%else %do;\n\t\t\t\t/*\n\t\t\t\t\tIf the message column doesn't exist, give a default value back.\n\t\t\t\t*/\n\t\t\t\t%let message = ERROR: The root- and/or jobrequest table does not exist for the initial response file. Unable to retrieve the log file.;\n\t\t\t%end;\n\t\t%end;\n\t\t/*\n\t\t\tClear the library reference, if it exists.\n\t\t*/\n\t\t%if %sysfunc(libref(resp)) EQ 0 %then %do;\n\t\t\tlibname resp clear;\n\t\t%end;\n\t%end;\n\t%else %do;\n\t\t%let message = ERROR: No response file received.;\n\t%end;\n\t/*\n\t\tIn case the message macro variable isn't empty, make that known for the end-user.\n\t*/\n\t%if (%superq(message) ne ) %then %do;\n\t\tdata message;\n\t\t\tattrib JobExecutionId length=$36.;\n\t\t\tattrib logFile length=$256.;\n\t\t\tattrib message length=$256.;\n\t\t\t\t\t\t\n\t\t\tJobExecutionId = \"&jobExecutionId\";\n\t\t\tmessage = \"&message\";\n\t\t\toutput;\n\t\trun;\n\t\tproc append base=&_output data=work.message force; run;\n\t%end;\n%mend GetJobExecutionLog;\n\n%macro calling_GetJobExecutionLog;\n\t/*\n\t\tFor each id from the input table, call the 'GetJobExecutionLog' macro.\n\t*/\n\t%if &_serverType eq sasserver %then %do;\n\t\t%do index = 1 %to &nbr_ids;\n\t\t\t%put NOTE: Downloading the log file for Job execution Id: &&ID&index;\n\t\t\t%GetJobExecutionLog(jobExecutionId=&&ID&index);\n\t\t%end;\n\t%end;\n\t%else %do;\n\t\t%put ERROR: Please select a location on the SAS Server. SAS Content folders are not supported by this custom step;\n\t\t%abort exit;\n\t%end;\n%mend calling_GetJobExecutionLog;\n\n%calling_GetJobExecutionLog;\n\n/*\n\tRemove all macro variables from memory.\n*/\n%symdel nbr_ids /NOWARN;\n%symdel is_valid_json /NOWARN;\n\n/*\n\tRemove all macros from memory.\n*/\n%SYSMACDELETE is_json_file / NOWARN;\n%SYSMACDELETE GetJobExecutionLog / NOWARN;\n%SYSMACDELETE calling_GetJobExecutionLog / NOWARN;"}}
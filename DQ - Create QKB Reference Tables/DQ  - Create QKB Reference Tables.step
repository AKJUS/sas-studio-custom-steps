{"creationTimeStamp":"2023-08-30T15:12:16.847Z","modifiedTimeStamp":"2023-09-20T14:12:04.933Z","createdBy":"sasadm","modifiedBy":"sasadm","name":"Create QKB Reference Tables.step","displayName":"DQ - Create QKB Reference Tables.step","localDisplayName":"DQ - Create QKB Reference Tables.step","properties":{},"links":[{"method":"GET","rel":"self","href":"/dataFlows/steps/0f10f994-d5bb-496c-8edf-943bdfb15893","uri":"/dataFlows/steps/0f10f994-d5bb-496c-8edf-943bdfb15893","type":"application/vnd.sas.data.flow.step"},{"method":"GET","rel":"alternate","href":"/dataFlows/steps/0f10f994-d5bb-496c-8edf-943bdfb15893","uri":"/dataFlows/steps/0f10f994-d5bb-496c-8edf-943bdfb15893","type":"application/vnd.sas.data.flow.step.summary"},{"method":"GET","rel":"up","href":"/dataFlows/steps","uri":"/dataFlows/steps","type":"application/vnd.sas.collection","itemType":"application/vnd.sas.data.flow.step.summary"},{"method":"PUT","rel":"update","href":"/dataFlows/steps/0f10f994-d5bb-496c-8edf-943bdfb15893","uri":"/dataFlows/steps/0f10f994-d5bb-496c-8edf-943bdfb15893","type":"application/vnd.sas.data.flow.step","responseType":"application/vnd.sas.data.flow.step"},{"method":"DELETE","rel":"delete","href":"/dataFlows/steps/0f10f994-d5bb-496c-8edf-943bdfb15893","uri":"/dataFlows/steps/0f10f994-d5bb-496c-8edf-943bdfb15893"},{"method":"GET","rel":"transferExport","href":"/dataFlows/steps/0f10f994-d5bb-496c-8edf-943bdfb15893","uri":"/dataFlows/steps/0f10f994-d5bb-496c-8edf-943bdfb15893","responseType":"application/vnd.sas.transfer.object"},{"method":"PUT","rel":"transferImportUpdate","href":"/dataFlows/steps/0f10f994-d5bb-496c-8edf-943bdfb15893","uri":"/dataFlows/steps/0f10f994-d5bb-496c-8edf-943bdfb15893","type":"application/vnd.sas.transfer.object","responseType":"application/vnd.sas.summary"}],"metadataVersion":0.0,"version":2,"type":"code","flowMetadata":{"inputPorts":[],"outputPorts":[]},"ui":"{\n\t\"showPageContentOnly\": true,\n\t\"pages\": [\n\t\t{\n\t\t\t\"id\": \"page1\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"Create QKB Reference Tables\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"qkbLibName\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Specify SAS library name for DQREF tables\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"regexp\": \"^(?=.{1,8}$)([a-zA-Z_][a-zA-Z0-9_]*)$\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"qkbLibPath\",\n\t\t\t\t\t\"type\": \"path\",\n\t\t\t\t\t\"label\": \"Specify SAS Server path for custom DQREF tables\",\n\t\t\t\t\t\"pathtype\": \"folder\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"page2\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"About\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"aboutInfo\",\n\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\"text\": \"This custom step analyzes the default Quality Knowledge Base (QKB) in SAS Compute and creates QKB Reference Tables for each of the definition types in the specified SAS Server location and creates a SAS Library.\\n\\nFor information on how to set a customized QKB as the default for SAS Compute, refer to this SAS Community article: https://communities.sas.com/t5/SAS-Communities-Library/SAS-Viya-Add-a-Customized-Quality-Knowledge-Base-QKB-to-CAS-and/ta-p/891719\\n\\nAlso, any custom data masking standardization definition must start with one of these three words: \\\"Mask\\\", \\\"Anonymize\\\", or \\\"Truncate\\\" to be included on the data masking definition (DM_MKDEF) table.\\n\\n\\nVersion 1.0    22SEP2023\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t],\n\t\"syntaxversion\": \"1.3.0\",\n\t\"values\": {\n\t\t\"qkbLibName\": \"CSTDQREF\",\n\t\t\"qkbLibPath\": \"\"\n\t}\n}","templates":{"SAS":"/* Data Quality - Enrichment: Get QKB Info and create QKBREF Tables */\n/* This code must be run in the SAS COMPUTE context.\n   It builds reference tables for the default QKB in SAS Compute */\n\n\n/* Suppress logging to avoid getting Max Log size exceeded warning */\noptions nosource nonotes ; \n\n\n/* Create macro variables from custom step selections */\n%let _dm_qkbOutLib = &qkbLibName; \n%let _dm_tempQkbOutPath = &qkbLibPath; \n\n\n/* Parse parts of the selected qkbOutPath */\n%let fileLoc=%qscan(&_dm_tempQkbOutPath,1,:);\n%put QKB File Location: &fileLoc;\n%let _dm_qkbOutPath=\"%qscan(&_dm_tempQkbOutPath,2,:)\";\n%put QKB File Path: &_dm_qkbOutPath;\n\n \n\n/* Macro to get QKB information and tokens */\n%macro dqputloc_dqref(loc, short=0, parsedefn=1); \n   /* Save the current value of the NOTES/NONOTES option\n      and then turn notes off. */\n   %let dqnotes = %sysfunc(getoption(NOTES));\n   options nosource nonotes;\n\n   /* Save the current value of the PAGESIZE option\n      and then increase the value to avoid pagebreaks in the\n      dqLocaleInfoList output. */\n   %let dqps = %sysfunc(getoption(PS));\n   options ps=32767;\n   \n   /* Prepare the LISTLOC value, uppercasing it, and transforming it into\n      the actual locale value if one wasn't passed in. */\n   %let listloc=%trim(%upcase(&loc));\n   %if &listloc= %then %do;\n      data _null_;\n         x=dqlocaleinfoget('loaded');\n         call symput('listloc', trim(scan(x, 1, ',')));\n      run;\n   %end;\n   \n   /* Check to make sure that the specified locale is loaded. */\n   data _null_;\n      x=upcase(dqlocaleinfoget('loaded'));\n      call symput('loaded', trim(x));\n      if index(x, \"&listloc\") = 0 then call symput('error', 1);\n      else call symput('error', 0);\n   run;\n   \n   /* If the specified locale is not loaded, error out. */\n   %if &error=1 %then %do;\n      %put ERROR: You specified a locale that is not loaded (&listloc).;\n      %put ERROR: The loaded locales are (&loaded).;\n      %put ERROR: The DQPUTLOC macro is terminating.;\n   %end;\n   /* If the specified locale is loaded, then proceed. */\n   %else %do;\n      /* Allocate a temporary file (in this case, actually a\n            source entry in the work library so that it will be\n            consistent from host to host, and it will automatically\n            be removed when SAS exits). */\n      filename dqtmp catalog 'work.temp.dqtmp.source';\n   \n      /* Re-direct the log to the source entry. */\n      proc printto log=dqtmp new;\n      run;\n   \n      /* Get the number of definitions written to help in parsing\n         the output. */\n      data _null_;\n         numdefns=dqLocaleInfoList('ALL', \"&listloc\");\n         call symput('numdefns', left(put(numdefns, 5.)));\n      run;\n   \n      /* Stop the redirection. */\n      proc printto;\n      run;\n   \n      /* Read the definitions from the source entry. */\n      data definitions(drop=line i done j tokens);\n         length line operation defnname $ 200;\n         length tokens $ 5000 token $ 50 parsedefn $ 50;\n         infile dqtmp truncover;\n         input line $char200.;\n         if line =:'OPERATION: ' then do;\n            input; /* Advance past the line of dashes. */\n            do i=1 to &numdefns;\n               input line $char200.;\n               operation=scan(line, 1, ':');\n               defnname=left(scan(line, 2, ':'));\n               parsedefn = '';\n               tokens='';\n               token='';\n   \n               /* Get the tokens associated with a parse definition. */\n               if operation='PARSE' then do;\n                  tokens=dqParseInfoGet(defnname, \"&listloc\");\n   \n                  done=0;\n                  j=1;\n                  do until(done);\n                     token=scan(tokens, j, ',');\n                     if token='' then done=1;\n                     else output;\n                     j+1;\n                  end;\n               end;\n   \n               /* Get the tokens associated with an extraction definition. */\n               if operation='EXTRACTION' then do;\n                  tokens=dqExtInfoGet(defnname, \"&listloc\");\n   \n                  done=0;\n                  j=1;\n                  do until(done);\n                     token=scan(tokens, j, ',');\n                     if token='' then done=1;\n                     else output;\n                     j+1;\n                  end;\n               end;\n   \n               /* Get the tokens associated with an identification definition. */\n               if operation='IDENTIFICATION' then do;\n                  tokens=dqIdentifyInfoGet(defnname, \"&listloc\");\n   \n                  done=0;\n                  j=1;\n                  do until(done);\n                     token=scan(tokens, j, ',');\n                     if token='' then done=1;\n                     else output;\n                     j+1;\n                  end;\n               end;\n   \n               /* Get the parse definition associated with a match\n                  definition (if any). */\n               else if operation='MATCH' then do;\n                  if &parsedefn=1 then\n                     parsedefn=dqMatchInfoGet(defnname, \"&listloc\");\n                  else parsedefn='';\n               end;\n   \n               /* Get the parse definition associated with a gender\n                  definition (if any). */\n               else if operation='GENDER' then do;\n                  if &parsedefn=1 then\n                     parsedefn=dqGenderInfoGet(defnname, \"&listloc\");\n                  else parsedefn='';\n               end;\n   \n               if (tokens eq '' or token ne '') then output;\n            end;\n            stop;\n         end;\n      run;\n   \n      /* Sort the data. */\n      proc sort data=definitions;\n         by operation defnname;\n      run;\n   \n      /* Read the data back in and generate the report to the SAS Log. */\n      data _null_;\n         set definitions;\n         by operation defnname;\n         length mixedop $ 100;\n   \n         /* Header for the whole report. */\n         if _n_=1 then do;\n            put //\n                \"The definitions in the &listloc locale are as follows: \"\n                /;\n         end;\n   \n         mixedop=substr(operation,1,1) || lowcase(substr(operation,2));\n   \n         /* Header for each operation. */\n         if first.operation then do;\n            /* Generate the long version of the header for each\n               definition type. */\n            if &short=0 then do;\n               put @1 '/*----------------------------------'\n                      '--------------------------------*/';\n               put @1 '/*' +1 operation \"DEFINITION(S)\" @69 '*/';\n               put @1 '/*' @69 '*/';\n               put @1 '/*'\n                   +1 mixedop\n                   'definitions are used by the following:' @69 '*/';\n   \n               /* Generate the static text for each definition type. */\n               if operation = 'PARSE' then do;\n                  put @1 '/*' @7 'dqParse function' @69 '*/';\n                  put @1 '/*' @7 'dqParseInfoGet function' @69 '*/';\n                  put @1 '/*' @7 'dqParseTokenGet function' @69 '*/';\n                  put @1 '/*' @7 'dqParseTokenPut function' @69 '*/';\n                  put @1 '/*' @7 'dqToken function' @69 '*/';\n   \n               end;\n               else if operation = 'MATCH' then do;\n                  put @1 '/*'\n                      @7 'dqMatch function'\n                      @69 '*/';\n                  put @1 '/*'\n                      @7 'dqMatchParsed function'\n                      @69 '*/';\n                  put @1 '/*'\n                      @7 'dqMatchInfoGet function'\n                      @69 '*/';\n                  put @1 '/*'\n                      @7 'DQMATCH procedure, CRITERIA statement'\n                      @69 '*/';\n                  put @1 '/*'\n                      @7 'DQSCHEME procedure, CREATE statement'\n                      @69 '*/';\n               end;\n               else if operation = 'GENDER' then do;\n                  put @1 '/*' @7 'dqGender function' @69 '*/';\n                  put @1 '/*' @7 'dqGenderParsed function' @69 '*/';\n               end;\n               else if operation = 'STANDARDIZATION' then do;\n                  put @1 '/*' @7 'dqStandardize function' @69 '*/';\n               end;\n               else if operation = 'IDENTIFICATION' then do;\n                  put @1 '/*' @7 'dqIdentify function' @69 '*/';\n               end;\n               else if operation = 'CASE' then do;\n                  put @1 '/*' @7 'dqCase function' @69 '*/';\n               end;\n               else if operation = 'GUESS' then do;\n                  put @1 '/*' @7 'dqLocaleGuess function' @69 '*/';\n               end;\n               else if operation = 'PATTERN' then do;\n                  put @1 '/*' @7 'dqPattern function' @69 '*/';\n               end;\n               else if operation = 'EXTRACTION' then do;\n                  put @1 '/*' @7 'dqExtract function' @69 '*/';\n                  put @1 '/*' @7 'dqExtInfoGet function' @69 '*/';\n                  put @1 '/*' @7 'dqExtTokenGet function' @69 '*/';\n                  put @1 '/*' @7 'dqExtTokenPut function' @69 '*/';\n               end;\n   \n               put @1 '/*----------------------------------'\n                      '--------------------------------*/';\n            end;\n   \n            /* Generate the short version of the header for each\n               definition type. */\n            else do;\n               put @1 operation \"DEFINITION(S):\";\n            end;\n         end;\n   \n         /* First print out each definition name... */\n         if first.defnname then\n            put @5 defnname;\n   \n         /* ...and then if it is a parse, match or gender definition which\n            has additional info, print that too. */\n         if operation='PARSE' then\n            put @8 'Token: ' token;\n         else if operation='EXTRACTION' then\n            put @8 'Token: ' token;\n         else if operation='IDENTIFICATION' then\n            put @8 'Token: ' token;\n         else if operation='MATCH' and parsedefn ne '' then\n            put @8 'The associated parse definition is \"'\n                parsedefn +(-1) '\".';\n         else if operation='GENDER' and parsedefn ne '' then\n            put @8 'The associated parse definition is \"'\n                parsedefn +(-1) '\".';\n   \n         /* Print out blank lines after each definition and after each\n            operation. */\n         if last.defnname then put;\n         if last.operation then put;\n      run;\n   %end;\n   \n   /* Reset NOTES/NONOTES and PAGESIZE to the original values. */\n   options &dqnotes ps=&dqps;\n   \n%mend dqputloc_dqref;\n\n\n\n/* This macro gets all the QKB locale and definition information\n   from the active QKB on the SAS Compute environment.  \n   This is specified using the configuration option -DQSETUPLOC\n*/\n%macro _dm_getQKBInfoCompute;\n\n   %global _dm_existsQKB _dm_existsQKB _dm_qkbCountInRepo _dm_numLocales _dm_allLocales _dm_qkbOutLib;\n\n   /* If no output library specified then write Compute QKB info out to WORK dir */\n   %if &_dm_qkbOutLib eq %then %do; %let _dm_qkbOutLib = %str(WORK); %end;\n\n   /* Get the system options to ensure a QKB is loaded */\n   proc optsave out = &_dm_qkbOutLib.._dm_options;\n   run;\n\n   /* Check if a system-set QKB exists */\n   proc sql noprint;\n      select count(OPTVALUE) into :_dm_existsQKB from &_dm_qkbOutLib.._dm_options where OPTNAME = \"DQSETUPLOC\";\n   quit;\n\n   /* If no QKB in the repo */\n   %if &_dm_existsQKB. eq 0 %then %do;\n      %put QKB is not referenced;\n   %end;\n\n   /* Else the QKB system default is referenced */\n   %else %do;\n\n      /* Get the list of the QKBs in the repo */\n      proc QKB;\n         LIST OUT = &_dm_qkbOutLib.._dm_qkbListOutAll;\n      run;\n\n      /* Check if the QKB is actually in the repo. */\n      proc sql noprint;\n         select count(quote(trim(QKB))) into :_dm_qkbCountInRepo from &_dm_qkbOutLib.._dm_qkbListOutAll where not missing(QKB);\n      quit;\n\n      /* If we have a qkb in the repo */\n      %if &_dm_qkbCountInRepo. > 0 %then %do;\n\n         /* Create base table to hold all definition info */\n         data &_dm_qkbOutLib.._dm_defList (replace=yes);\n            length Name $200 Type $200 Locale $5 Token $50;\n         run;\n\n         /* Create a base table for each definition type */\n         %do idxCurrType = 1 %to &_dm_allDefTypesCount;\n            %let currDefType=%scan(&_dm_allDefTypes,&idxCurrType,|);\n            data &_dm_qkbOutLib.._dm_&currDefType.DefList (replace=yes);\n               length Name $200 Type $200 Locale $5 Token $50;\n            run;\n         %end;\n\n         /* Get the list of available locales */\n         proc dqloclst out=&_dm_qkbOutLib.._dm_locList;\n         run;\n\n         /* Get the default QKB info */\n         proc sql noprint;\n            select trim(upcase(LOCALE)) into :_dm_allLocales separated by ' ' from &_dm_qkbOutLib.._dm_locList;\n            select count(LOCALE) into :_dm_numLocales from &_dm_qkbOutLib.._dm_locList;\n         quit;\n\n         /* Loop through each locale */\n         %let _dm_currLoc=;\n         %do idxLoc = 1 %to &_dm_numLocales;\n\n            /* Load the current locale to query its definitions */\n            %let _dm_currLoc = %scan(&_dm_allLocales,&idxLoc,' ');\n            %DQLOAD(DQLOCALE=(&_dm_currLoc));\n            %dqputloc_dqref(&_dm_currLoc, PARSEDEFN=0, SHORT=1);\n\n            /* Add the current locale as a var */\n            data &_dm_qkbOutLib.._dm_definitions (replace=yes);\n               /* Rename the Compute output column names to match CAS */\n               set work.definitions (keep=operation defnname token rename=(operation=Type defnname=Name));\n               Locale=\"&_dm_currLoc\";\n               /* Compute output is uppercase. CAS uses propercase. Normalize to propercase */\n               Type = propcase(Type);\n               /* Compute calls Locale Guess definitions Guess. Normalize to the\n               CAS value, Locale Guess, which is more correct and specific. There is no\n               ambiguity risk with Language Guess definitions because those cannot be\n               surfaced in the QKB.\n               */\n               if Type = \"Guess\" then Type = \"Locale Guess\";\n            run;\n\n            /* Loop throught each definition type */\n            %do idxCurrType = 1 %to &_dm_allDefTypesCount;\n\n               /* Create dataset for this definition type */\n               %let currDefType=%scan(&_dm_allDefTypes,&idxCurrType,|);\n               data &_dm_qkbOutLib.._dm_currDefList (replace=yes where=(upcase(Type)=TRANWRD(\"&currDefType\",'_',' ')));\n                  set &_dm_qkbOutLib.._dm_definitions;\n                  by Locale;\n                  length Name_Tmp $200 Type_Tmp $200 Token_Tmp $50 Locale_Tmp $5;\n                  Name_Tmp = Name;\n                  Type_Tmp = Type;\n                  Locale_Tmp = Locale;\n                  Token_Tmp = token;\n                  drop Name Type Locale token;\n                  rename Name_Tmp=Name; rename Type_Tmp=Type; rename Locale_Tmp=Locale; rename Token_Tmp=Token;\n               run;\n\n               /* Append results to base definition type tables to accumulate definitions for each def type info for all locales */\n               proc append base=&_dm_qkbOutLib.._dm_&currDefType.DefList force nowarn\n                  data=&_dm_qkbOutLib.._dm_currDefList;\n               run;\n\n               /* Remove blank initial row after append operation */\n               data &_dm_qkbOutLib.._dm_&currDefType.DefList;\n                  set &_dm_qkbOutLib.._dm_&currDefType.DefList (where=(not missing(Locale)));\n               run;\n\n               /* Drop the temp table before the definition type loop increments */\n               proc sql noprint;\n                 drop table &_dm_qkbOutLib.._dm_currDefList;\n               quit;\n\n            %end; /* end %do idxCurrType = 1 %to &_dm_allDefTypesCount; */\n\n            /* Append results to base definition table of all definitions for all locales */\n            proc append base=&_dm_qkbOutLib.._dm_defList force nowarn\n               data=&_dm_qkbOutLib.._dm_definitions;\n            run;\n\n            /* Drop the temp tables before the locale loop increments */\n            proc sql noprint;\n               drop table work.definitions, &_dm_qkbOutLib.._dm_definitions;\n            quit;\n\n            /* Unload all locales before next locale iteration */\n            %DQUNLOAD;\n\n         %end; /* end %do idxLoc = 1 %to &_dm_numLocales; */\n\n         /* Remove blank initial row after append operation */\n         data &_dm_qkbOutLib.._dm_defList;\n            set &_dm_qkbOutLib.._dm_defList (where=(not missing(Locale)));\n         run;\n\n         /* The definitions output table of dqputloc has definition entries for each token of each parse or\n         extraction definition. We dont need this info, so deduplicate the tables for these two definition types.\n         */\n         proc sort data=&_dm_qkbOutLib.._dm_PARSEDEFLIST nodup;\n            by Locale;\n         run;\n         proc sort data=&_dm_qkbOutLib.._dm_EXTRACTIONDEFLIST nodup;\n            by Locale;\n         run;\n\n      %end; /* end If we have a qkb in the repo */\n\n   %end; /* end else the QKB system default is referenced */\n\n   /* Delete temporary tables */\n   proc datasets lib = &_dm_qkbOutLib. nolist nowarn memtype = (data view);\n      delete _dm_options _dm_qkbListOutAll ;\n   quit;\n\n%mend _dm_getQKBInfoCompute;\n\n\n\n/* This macro gets the list of QKB definitions */\n%macro _dm_getQKBInfo;\n\n   %global _dm_allDefTypes _dm_allDefTypesCount _dm_qkbListType _dm_qkbOutLib;\n\n   /* Create macro variable to hold all definitions types */\n   %let _dm_allDefTypes = CASE|EXTRACTION|GENDER|LOCALE_GUESS|IDENTIFICATION|MATCH|PARSE|PATTERN|STANDARDIZATION;\n   %let _dm_allDefTypesCount = %eval(%sysfunc(countc(&_dm_allDefTypes,'|'))+1);\n\n   %_dm_getQKBInfoCompute;\n\n%mend _dm_getQKBInfo;\n\n\n/* Create Final Tables for DQREF for Customized QKB */\n%macro _dm_BuildDQREFTables;\n\n    /* delete DM_LOC table if exists */\n\t%if %sysfunc(exist(&_dm_qkbOutLib..DM_LOC)) \n\t\t%then %do;\n\t\t\tproc delete data=&_dm_qkbOutLib..DM_LOC;\n\t\t\trun;\n\t\t%end;\n\n\t/* Create DM_LOC Table */\n\tproc sql ;\n\t\tcreate table &_dm_qkbOutLib..DM_LOC as\n\t\t\tSELECT x.Locale AS DM_LOCALE, y.DM_CNTRY_LONG,\n\t\t\ty.DM_LANG_LONG, y.DM_DESC, y.DM_LANG_SHORT,\n\t\t\ty.DM_CNTRY_SHORT from\n\t\t\t&_dm_qkbOutLib.._DM_LOCLIST as x \n    \t\tleft join SASDQREF.DM_LOC as y\n\t\t\ton x.Locale = y.DM_LOCALE ;\n\t\tquit ;\n\n\t\t/* Delete Temporary Locale list table */\n\t\tproc datasets library=&_dm_qkbOutLib. nolist;\n    \t\tdelete _DM_LOCLIST ;\n\t\tquit;\n\n\t/* Create macro variable to hold all definitions types */\n\t%let _dm_allTempTables = _DM_CASEDEFLIST|_DM_DEFLIST|_DM_EXTRACTIONDEFLIST|_DM_GENDERDEFLIST|_DM_IDENTIFICATIONDEFLIST|_DM_LOCALE_GUESSDEFLIST|_DM_MATCHDEFLIST|_DM_PARSEDEFLIST|_DM_PATTERNDEFLIST|_DM_STANDARDIZATIONDEFLIST ;\n\t%let _dm_allTablesCount = %eval(%sysfunc(countc(&_dm_allTempTables,'|'))+1);\n\t%let _dm_allFinalTables = DM_CADEF|DM_DEF|DM_EXDEF|DM_GNDEF|DM_IDDEF|DM_LGDEF|DM_MADEF|DM_PADEF|DM_PTDEF|DM_STDEF ;\n\n\t/* Create Final Definition Tables */\n\t%do idxCurrTable = 1 %to &_dm_allTablesCount;\n\t\t%let currTempTable=%scan(&_dm_allTempTables,&idxCurrTable,|);\n\t\t%let currFinalTable=%scan(&_dm_allFinalTables,&idxCurrTable,|);\n\n    \t/* Delete Final table if exists */\n\t\t%if %sysfunc(exist(&_dm_qkbOutLib..&currFinalTable)) \n\t\t\t%then %do;\n\t\t\t\tproc delete data=&_dm_qkbOutLib..&currFinalTable;\n\t\t\t\trun;\n\t\t\t%end;\n\n\t\tproc sql ;\n\t\t\tcreate table &_dm_qkbOutLib..&currFinalTable as\n\t\t\t\tSELECT x.Name AS DM_NAME, \n    \t\t\tx.Type AS DM_TYPE, \n    \t\t\tx.Locale AS DM_LOCALE, y.DM_CNTRY_LONG,\n\t\t\t\ty.DM_LANG_LONG, y.DM_DESC, y.DM_LANG_SHORT,\n\t\t\t\ty.DM_CNTRY_SHORT, x.Token as DM_TOKENS from\n\t\t\t\t&_dm_qkbOutLib..&currTempTable as x \n    \t\t\tleft join &_dm_qkbOutLib..DM_LOC as y\n\t\t\t\ton x.Locale = y.DM_LOCALE ;\n\t\tquit ;\n\n\t\t/* Delete Temporary Data Sets */\n\t\tproc datasets library=&_dm_qkbOutLib. nolist;\n    \t\tdelete &currTempTable ;\n\t\tquit;\n\n\t%end;\n\n\t/* Create Data Masking Table based on Definition Names from Standardization Table */\n\tdata &_dm_qkbOutLib..DM_MKDEF ;\n    \tset &_dm_qkbOutLib..DM_STDEF ;\n    \twhere upcase(scan(DM_NAME,1)) in (\"MASK\",\"ANONYMIZE\",\"TRUNCATE\") ;\n\trun ;\n\n\t/* Fix Identification Analysis Table for Identities that have Commas */\n    proc sql ;\n\t\tupdate &_dm_qkbOutLib..DM_IDDEF\n\t\tset DM_TOKENS = 'CONGO, DEMOCRATIC REPUBLIC OF'\n\t\twhere DM_TOKENS = 'CONGO' ;\n\t\t\n\t\tdelete from &_dm_qkbOutLib..DM_IDDEF where DM_TOKENS = ' DEMOCRATIC REPUBLIC OF' ;\n\n\t\tupdate &_dm_qkbOutLib..DM_IDDEF\n\t\tset DM_TOKENS = 'MICRONESIA, FEDERATED STATES OF'\n\t\twhere DM_TOKENS = 'MICRONESIA' ;\n\n\t\tdelete from &_dm_qkbOutLib..DM_IDDEF where DM_TOKENS = ' FEDERATED STATES OF' ;\n\n\t\tupdate &_dm_qkbOutLib..DM_IDDEF\n\t\tset DM_TOKENS = 'IRAN, ISLAMIC REPUBLIC OF'\n\t\twhere DM_TOKENS = 'IRAN' ;\n\n\t\tdelete from &_dm_qkbOutLib..DM_IDDEF where DM_TOKENS = ' ISLAMIC REPUBLIC OF' ;\n\n\t\tupdate &_dm_qkbOutLib..DM_IDDEF\n\t\tset DM_TOKENS = \"KOREA, DEMOCRATIC PEOPLE'S REP\"\n\t\twhere DM_TOKENS = \" DEMOCRATIC PEOPLE'S REP\" ;\n\n\t\tupdate &_dm_qkbOutLib..DM_IDDEF\n\t\tset DM_TOKENS = 'KOREA, REPUBLIC OF'\n\t\twhere DM_TOKENS = 'KOREA' ;\n\n\t\tupdate &_dm_qkbOutLib..DM_IDDEF\n\t\tset DM_TOKENS = 'MOLDOVA, REPUBLIC OF'\n\t\twhere DM_TOKENS = 'MOLDOVA' ;\n\n\t\tdelete from &_dm_qkbOutLib..DM_IDDEF where DM_TOKENS = ' REPUBLIC OF' ;\n\n\t\tupdate &_dm_qkbOutLib..DM_IDDEF\n\t\tset DM_TOKENS = 'PALESTINIAN TERRITORY, OCCUPIED'\n\t\twhere DM_TOKENS = 'PALESTINIAN TERRITORY' ;\n\n\t\tdelete from &_dm_qkbOutLib..DM_IDDEF where DM_TOKENS = ' OCCUPIED' ;\n\n\t\tupdate &_dm_qkbOutLib..DM_IDDEF\n\t\tset DM_TOKENS = 'VIRGIN ISLANDS, BRITISH'\n\t\twhere DM_TOKENS = ' BRITISH' ;\n\n\t\tupdate &_dm_qkbOutLib..DM_IDDEF\n\t\tset DM_TOKENS = 'VIRGIN ISLANDS, U.S'\n\t\twhere DM_TOKENS = ' U.S' ;\n\n\t\tdelete from &_dm_qkbOutLib..DM_IDDEF where DM_TOKENS = 'VIRGIN ISLANDS' ;\n\tquit;\n\n\t/* Remove duplicate rows from DM_IDDEF */\n\tproc sql ;\n\t\tcreate table &_dm_qkbOutLib..DM_IDDEF_NoDupes as\n \t\tselect DISTINCT * from &_dm_qkbOutLib..DM_IDDEF;\n\tquit ;\n\tproc datasets lib=&_dm_qkbOutLib;\n\t\tdelete DM_IDDEF ;\n\t\tchange DM_IDDEF_NoDupes = DM_IDDEF ;\n\tquit;\n\n%mend _dm_BuildDQREFTables;\n\n\n\n/*Perform this section if Path Location is SAS Content */\n%if &fileLoc=sascontent %then %do; \n\t%put ERROR: You must select a path on the SAS Server;\n    %let _dm_qkbOutPath=INVALID;\n%end ; /* end if Path Location is SAS Content */\n\n/* check if path exists on the SAS server */\n%let _dm_path_exists=%sysfunc(fileexist(&_dm_qkbOutPath));\n/* If path doesn't exist */\n%if &_dm_path_exists. eq 0 %then %do;\n\t%put ERROR: Specified path for the library does not exist on the SAS Server;\n%end; /* end if path does not exist */\n\t/* If path exists */\n\t%else %do;\n\t\t/* Create library for DQREF Tables */\n\t\tlibname &_dm_qkbOutLib &_dm_qkbOutPath;  \n\n\t\t%_dm_getQKBInfo;  /* Write QKB Info to Temp Tables */\n\t\t%_dm_BuildDQREFTables;  /* Write QKB Info to Final Tables */\n\n\n\t%end ; /* end if path exists */\n\n\n/* END OF PROGRAM */"}}
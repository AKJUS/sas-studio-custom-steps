{"creationTimeStamp":"2022-06-24T19:12:22.562Z","modifiedTimeStamp":"2022-09-20T21:38:46.208Z","createdBy":"Stephan.Weigandt@sas.com","modifiedBy":"Stephan.Weigandt@sas.com","name":"Dynamic_Aggregations_from_Timeseries_DAFT.step","displayName":"Dynamic_Aggregations_from_Timeseries_DAFT.step","localDisplayName":"Dynamic_Aggregations_from_Timeseries_DAFT.step","properties":{},"links":[{"method":"GET","rel":"self","href":"/dataFlows/steps/029a3c6f-24dc-44ee-bf3d-760f4cd09f55","uri":"/dataFlows/steps/029a3c6f-24dc-44ee-bf3d-760f4cd09f55","type":"application/vnd.sas.data.flow.step"},{"method":"GET","rel":"alternate","href":"/dataFlows/steps/029a3c6f-24dc-44ee-bf3d-760f4cd09f55","uri":"/dataFlows/steps/029a3c6f-24dc-44ee-bf3d-760f4cd09f55","type":"application/vnd.sas.data.flow.step.summary"},{"method":"GET","rel":"up","href":"/dataFlows/steps","uri":"/dataFlows/steps","type":"application/vnd.sas.collection","itemType":"application/vnd.sas.data.flow.step.summary"},{"method":"PUT","rel":"update","href":"/dataFlows/steps/029a3c6f-24dc-44ee-bf3d-760f4cd09f55","uri":"/dataFlows/steps/029a3c6f-24dc-44ee-bf3d-760f4cd09f55","type":"application/vnd.sas.data.flow.step","responseType":"application/vnd.sas.data.flow.step"},{"method":"DELETE","rel":"delete","href":"/dataFlows/steps/029a3c6f-24dc-44ee-bf3d-760f4cd09f55","uri":"/dataFlows/steps/029a3c6f-24dc-44ee-bf3d-760f4cd09f55"},{"method":"GET","rel":"transferExport","href":"/dataFlows/steps/029a3c6f-24dc-44ee-bf3d-760f4cd09f55","uri":"/dataFlows/steps/029a3c6f-24dc-44ee-bf3d-760f4cd09f55","responseType":"application/vnd.sas.transfer.object"},{"method":"PUT","rel":"transferImportUpdate","href":"/dataFlows/steps/029a3c6f-24dc-44ee-bf3d-760f4cd09f55","uri":"/dataFlows/steps/029a3c6f-24dc-44ee-bf3d-760f4cd09f55","type":"application/vnd.sas.transfer.object","responseType":"application/vnd.sas.summary"}],"metadataVersion":0.0,"version":2,"type":"code","flowMetadata":{"inputPorts":[{"name":"input_ds_ui","displayName":"input_ds_ui","localDisplayName":"input_ds_ui","minEntries":1,"maxEntries":1,"type":"table"}],"outputPorts":[{"name":"outputtable_ui","displayName":"outputtable_ui","localDisplayName":"outputtable_ui","minEntries":1,"maxEntries":1,"type":"table","requiresStructure":false}]},"ui":"{\n\t\"showPageContentOnly\": true,\n\t\"pages\": [\n\t\t{\n\t\t\t\"id\": \"InputData\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"Input Data\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"input_ds_ui\",\n\t\t\t\t\t\"type\": \"inputtable\",\n\t\t\t\t\t\"label\": \"Provide the Transaction table to be aggregated\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"sum_variables_seq_ui\",\n\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\"label\": \"Calculate the sum of:\",\n\t\t\t\t\t\"order\": true,\n\t\t\t\t\t\"columntype\": \"n\",\n\t\t\t\t\t\"max\": null,\n\t\t\t\t\t\"min\": null,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"table\": \"input_ds_ui\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"min_variables_seq_ui\",\n\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\"label\": \"Calculate the min of:\",\n\t\t\t\t\t\"order\": true,\n\t\t\t\t\t\"columntype\": \"n\",\n\t\t\t\t\t\"max\": null,\n\t\t\t\t\t\"min\": null,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"table\": \"input_ds_ui\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"max_variables_seq_ui\",\n\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\"label\": \"Calculate the max of:\",\n\t\t\t\t\t\"order\": true,\n\t\t\t\t\t\"columntype\": \"n\",\n\t\t\t\t\t\"max\": null,\n\t\t\t\t\t\"min\": null,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"table\": \"input_ds_ui\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"avg_variables_seq_ui\",\n\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\"label\": \"Calculate the average of :\",\n\t\t\t\t\t\"order\": true,\n\t\t\t\t\t\"columntype\": \"n\",\n\t\t\t\t\t\"max\": null,\n\t\t\t\t\t\"min\": null,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"table\": \"input_ds_ui\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"entity_def_seq_ui\",\n\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\"label\": \"Vars to define the smallest entity:\",\n\t\t\t\t\t\"order\": true,\n\t\t\t\t\t\"columntype\": \"a\",\n\t\t\t\t\t\"max\": null,\n\t\t\t\t\t\"min\": 1,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"table\": \"input_ds_ui\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"date_variable_ui\",\n\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\"label\": \"Provide the date variable:\",\n\t\t\t\t\t\"order\": false,\n\t\t\t\t\t\"columntype\": \"n\",\n\t\t\t\t\t\"max\": 1,\n\t\t\t\t\t\"min\": 1,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"table\": \"input_ds_ui\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"outputdata\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"Output Data\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"outputtable_ui\",\n\t\t\t\t\t\"type\": \"outputtable\",\n\t\t\t\t\t\"label\": \"Output Table Name\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"placeholder\": \"E.g. public.output_table\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"time_granularity_ui\",\n\t\t\t\t\t\"type\": \"dropdown\",\n\t\t\t\t\t\"label\": \"Select Time Granularity:\",\n\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"day\",\n\t\t\t\t\t\t\t\"label\": \"By Day\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"week\",\n\t\t\t\t\t\t\t\"label\": \"By Week\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"month\",\n\t\t\t\t\t\t\t\"label\": \"By Month\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"quarter\",\n\t\t\t\t\t\t\t\"label\": \"By Quarter\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"processingoptions\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"Processing Options\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"agg_period_seq_ui\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Provide desired aggregation periods (separated by #, in chosen time granularity):\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"lag_period_seq_ui\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Provide desired delay/lag (separated by #, in chosen time granularity):\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"period_start_year_ui\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Aggregation Start Year:\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"period_end_year_ui\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Aggregation End Year:\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"admin\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"Admin Options\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"debug_mode_ui\",\n\t\t\t\t\t\"type\": \"radiogroup\",\n\t\t\t\t\t\"label\": \"Run in debug mode?\",\n\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"1\",\n\t\t\t\t\t\t\t\"label\": \"Yes\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"0\",\n\t\t\t\t\t\t\t\"label\": \"No\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"write_log_to_file_ui\",\n\t\t\t\t\t\"type\": \"radiogroup\",\n\t\t\t\t\t\"label\": \"Write Log into File? (\\\"Yes\\\" will open input field below for path selection)\",\n\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"1\",\n\t\t\t\t\t\t\t\"label\": \"Yes\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"0\",\n\t\t\t\t\t\t\t\"label\": \"No\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"log_file_path_ui\",\n\t\t\t\t\t\"type\": \"path\",\n\t\t\t\t\t\"label\": \"Path for logfile creation\",\n\t\t\t\t\t\"pathtype\": \"folder\",\n\t\t\t\t\t\"placeholder\": \"Select directory in SAS Server or SAS Content\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"visible\": [\n\t\t\t\t\t\t\"$write_log_to_file_ui\",\n\t\t\t\t\t\t\"=\",\n\t\t\t\t\t\t\"1\"\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"run_everything_in_CAS_ui\",\n\t\t\t\t\t\"type\": \"radiogroup\",\n\t\t\t\t\t\"label\": \"Run everything in CAS?\",\n\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"1\",\n\t\t\t\t\t\t\t\"label\": \"Yes\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"0\",\n\t\t\t\t\t\t\t\"label\": \"No\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"options_seq_ui\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Provide options to be applied for this run (only single options allowed like mprint, nosource, etc).\",\n\t\t\t\t\t\"placeholder\": \"mprint notes source\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"about\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"About\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"text1\",\n\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\"text\": \"DAFT - Dynamic Aggregations from Timeseries\\nVersion: 2.0.1\\n\\nFor questions/feedback/ideas, please contact :\\nstephan.weigandt@sas.com\\n\\nPurpose:\\n\\nThis Custom Step enables SAS Studio Flow users to easily perform dynamic aggregations on timeseries data by the push of a button.\\n\\nWhat does dynamic exactly means?\\nLet's explain based on an example: often times the outcome of events is dependent on other events that happened in the past. So it is important to get the view on the data how something looked like e.g. 4 weeks ago/7 weeks, etc... ago. And how does it look like back then when looking at the aggregate data of 2 weeks/3 weeks, etc...\\n\\nAlso, often times it is not known which time parameters are important to look at, hence it might be important to create a whole bunch of combinations and then let the statistic decide which combination is important. \\n\\nDAFT allows to calculate an unlimited amount of combinations if necessary.\\n\\nAt this point, DAFT allows the following aggregation functions:\\n- sum \\n- mean\\n- min \\n- max\\n\\nThe aggregations are based on one of the following time units:\\n- day \\n- week\\n- month\\n- quarter\\n\\nWith time series data usually being very granular, aggregating to higher level is necessary to allow best results for analytic purposes. \\nUsually it depends on the problem which granularity to choose. \\n\\nThe output dataset is then made available based on that chosen granularity. \\n\\nExample:\\nWeather data is available on a minute basis, and the problem at hand requires to look at the data on a weekly basis and it is required to look at the summed up precipitation over 1 week and 2 weeks for both 4 weeks and 8 weeks ago. \\n\\nThe aggregation sequence that needs to be provided is: 1#2\\nThe lag sequence that needs to be provided is: 4#8\\n\\nDAFT then creates all combinations between aggregation and lag sequence and the output variables would look like:\\nprecipitation_sum1L4\\nprecipitation_sum1L8\\nprecipitation_sum2L4\\nprecipitation_sum2L8\\n\\nwith \\\"sum\\\" describing the statistic that is being looked at for that variable, and the number behind it describes the length based on the selected unit, and \\\"L\\\" describing which lag is being looked. \\n\\nSince the granularity is \\\"By Week\\\", DAFT would create the following 2 time variables:\\n_DAFT_year\\n_DAFT_week\\n\\nAdditionally the output dataset contains the variables that describe the entity. \\nIn the weather example, this could the region/county level, or zip code level, etc...\\nIn other examples, e.g. when the transaction data is e.g. bank data, the smallest entity could be person, household, company or parent company.\\n\\n\\nCopy/paste these next few lines of code into SAS Studio - SAS Program tab in order to create a test timeseries dataset for playing around:\\n*******\\ndata work.sample_aggregation_ds;\\n\\tformat \\n\\t\\tcurrent_date date9.;\\n\\tdrop\\n\\t\\tcounter;\\n\\tcurrent_date = 20084;\\n\\tcounter = 0;\\n\\t/**\\n\\tloop through weeks/days to create timeseries skeleton\\n\\t**/\\n\\tdo week = 1 to 52;\\n\\t\\tdo day = 1 to 7;\\n\\t\\t\\tcounter = counter + 1;\\n\\t\\t\\t/* \\n\\t\\t\\tthis produced precipitation will always sum up to the current week number when \\n\\t\\t\\tweekly aggregated\\n\\t\\t\\t*/\\n\\t\\t\\tprecipitation = week/7;\\n\\t\\t\\t/*\\n\\t\\t\\tthe max of temp_min will always be the current week number when weekly aggregated\\n\\t\\t\\t*/\\n\\t\\t\\ttemp_min = week - (day - 1)/week;\\n\\t\\t\\t/*\\n\\t\\t\\tthe min of temp_max will always be the current week number when weekly aggregated\\n\\t\\t\\t*/\\n\\t\\t\\ttemp_max = week + (week * (day-1))**2;\\n\\t\\t\\tcurrent_date = current_date + 1;\\n\\t\\t\\t/*\\n\\t\\t\\tcreate random entity number between 0 and 1, also create an entity number 2, for which \\n\\t\\t\\tabove rules apply for summation expectation\\n\\t\\t\\t*/\\n\\t\\t\\tentity = floor(mod(ranuni(counter)*100,2));\\n\\t\\t\\tcal_week = week(current_date);\\n\\t\\t\\toutput;\\n\\t\\t\\tentity = 2;\\n\\t\\t\\toutput;\\n\\t\\tend;\\n\\tend;\\nrun;\\n**************\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t],\n\t\"syntaxversion\": \"1.3.0\",\n\t\"values\": {\n\t\t\"input_ds_ui\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"sum_variables_seq_ui\": [],\n\t\t\"min_variables_seq_ui\": [],\n\t\t\"max_variables_seq_ui\": [],\n\t\t\"avg_variables_seq_ui\": [],\n\t\t\"entity_def_seq_ui\": [],\n\t\t\"date_variable_ui\": [],\n\t\t\"outputtable_ui\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"time_granularity_ui\": {\n\t\t\t\"value\": \"month\",\n\t\t\t\"label\": \"By Month\"\n\t\t},\n\t\t\"agg_period_seq_ui\": \"1#2\",\n\t\t\"lag_period_seq_ui\": \"1#4\",\n\t\t\"period_start_year_ui\": \"2015\",\n\t\t\"period_end_year_ui\": \"2021\",\n\t\t\"debug_mode_ui\": {\n\t\t\t\"value\": \"0\",\n\t\t\t\"label\": \"No\"\n\t\t},\n\t\t\"write_log_to_file_ui\": {\n\t\t\t\"value\": \"0\",\n\t\t\t\"label\": \"No\"\n\t\t},\n\t\t\"log_file_path_ui\": \"\",\n\t\t\"run_everything_in_CAS_ui\": {\n\t\t\t\"value\": \"1\",\n\t\t\t\"label\": \"Yes\"\n\t\t},\n\t\t\"options_seq_ui\": \"\"\n\t},\n\t\"promptHierarchies\": []\n}","templates":{"SAS":"data work._daft_option_setting_storage;\n\tlength\n\t\tnew_setting $24.\n\t\toriginal_setting $24.\n\t\tnew_setting_seq $256.\n\t\t;\n\tnew_setting = \"\";\n\toriginal_setting = \"\";\n\tnew_setting_seq = \"\";\n\tnumberofsettings = 0;\n\tif 0;\nrun;\n%let _daft_option_validvarname_org = %sysfunc(getoption(validvarname));\noption validvarname = any;\n%if \"&options_seq_ui\" ne \"\" %then\n%do;\ndata _daft_option_setting_storage;\n\tlength new_setting $24.;\n\tnew_setting_seq = strip(\"&options_seq_ui\");\n\tnumberofsettings = count(new_setting_seq, \" \") + 1;\n\t\n\tdo i = 1 to numberofsettings;\n\t\tnew_setting = \"\";\n\t\tnew_setting = scan(new_setting_seq, i, \" \");\n\t\tif not missing(new_setting) then\n\t\tdo;\n\t\t\toriginal_setting = getoption(new_setting);\n\t\t\toutput;\n\t\t\tcall execute(\"option \"||new_Setting||\";\");\n\t\n\t\tend;\n\tend;\n\trun;\t\n%end;\n \n \n%let production_mode = 1;\n%let fcmp_run_indicator = 0;\n%let install_mode_in_SAS_Content = 0;\n \n \n%let daft_delimiter = ;\n%macro set_os_dependent_values(\n\tsodv_delimiter = daft_delimiter\n\t);\n\t%if %upcase(&SYSSCP) = WIN %then\n\t%do;\n\t\t%let &sodv_delimiter = \\;\n\t%end; %else\n\t%do;\n\t\t%let &sodv_delimiter = /;\n\t%end;\n%mend;\n%set_os_dependent_values(\n\tsodv_delimiter = daft_delimiter\n\t);\n \n \n/******************************************************************************\n \n%wordcnt\n________\n \n \nCounts the words in a list\n \n______________________________________________________________________________\n \n \nUSAGE:                         %wordcnt(list,delim)\n \n______________________________________________________________________________\n \nDESCRIPTION:\n \nFinds the number of words/tokens in a string.  The user specifies a\ndelimiter e.g. # to identify what separates the words.  The macro should be\ncalled in the following way, e.g. %let x=%wordcnt(item1#item2 item2a#item3, '#').  After running\nthe macro x will be assigned the value of wordcnt.\n______________________________________________________________________________\n \n \nINPUT PARAMETERS AND KEYWORDS:\n \nlist            the name of the string.\ndelim           the delimiter e.g. '#'.\n______________________________________________________________________________\n \n \nCALLS: none.\n______________________________________________________________________________\n \nNOTES: (Initials, date, summary)\n \nstweig    20200406  First officially Released Version\n______________________________________________________________________________\n \n*******************************************************************************/\n%macro wordcnt(\nlist,\ndelim\n)\n;\n%local\nword\nwc_count;\n%let wc_count = 0;\n%if %quote(&list) ne %then\n%do;\n%let word = %scan(%quote(&list), 1, &delim);\n%let word = %quote(&word);\n%do %while (&word ne);\n%let wc_count = %eval(&wc_count + 1);\n%let word = %scan(%quote(&list), &wc_count+1, &delim);\n%let word = %quote(&word);\n%end;\n%end;\n&wc_count\n%mend wordcnt;\n%macro load_final_data(\n\tlfd_libname = ,\n\twof2l_final_table_name = ,\n\tlfd_target_libname = bttrball,\n\tlfd_environment_macro_var_name = run_environment\n\t);\n\t%let wof2l_final_table_name = %upcase(&wof2l_final_table_name);\n\t%if &&&lfd_environment_macro_var_name = CAS %then\n\t%do;\n\t\tproc casutil;\n\t\t\tdroptable casdata = \"&wof2l_final_table_name\" incaslib = \"&lfd_target_libname\" quiet;\n\t\t\tdroptable casdata = \"&wof2l_final_table_name\" incaslib = \"&lfd_target_libname\" quiet;\n\t\tquit;\n\t%end;\n\t\tdata &lfd_target_libname..&wof2l_final_table_name;\n\t\t\tset &lfd_libname..&wof2l_final_table_name;\n\t\trun;\n\t%if &&&lfd_environment_macro_var_name = CAS %then\n\t%do;\n\t\tproc casutil;\n\t\t\tpromote casdata=\"&wof2l_final_table_name\" incaslib=\"&lfd_target_libname\"\n\t\t\t\t\toutcaslib=\"&lfd_target_libname\" casout=\"&wof2l_final_table_name\";\n\t\t\tsave casdata=\"&wof2l_final_table_name\" incaslib=\"&lfd_target_libname\"\n\t\t\t\t\toutcaslib=\"&lfd_target_libname\" casout=\"&wof2l_final_table_name\" replace;\n\t\tquit;\n\t\n\t%end;\n%mend load_final_data;\n/******************************************************************************\n \n%create_agg_by_period_by_lag\n________\n \nDESCRIPTION:\n \nThis program creates aggregates by time period and also by lag.\nThe resulting variables can be very helpful for forecasting and such.\n \n______________________________________________________________________________\n \nNOTES: (Initials, date, summary)\n \nstweig    \t20211102  First officially Released Version\n \n______________________________________________________________________________\n \n*******************************************************************************/\n \n%macro create_agg_by_period_by_lag_core(\n\tcabpblc_lag_aggregation_seq = ,\n\tcabpblc_lag_delay_seq = ,\n\tcabpblc_input_ds = ,\n\tcabpblc_output_ds = ,\n\tcabpblc_var_seq = ,\n\tcabpblc_debug_mode = 0,\n\tcabpblc_group_by = ,\n\tcabpblc_group_by_except_time = ,\n\tcabpblc_temp_libname = work\n\t);\n\t%local\n\t\tmax_lag_value\n\t\taggregation_count\n\t\tdelay_count\n\t\tagg_counter\n\t\taggregation\n\t\tdelay_counter\n\t\tcounter\n\t\tvarname\n\t\tcabpbl_target_lib_engine\n\t\trun_environment\n\t\tlast_of_ds_groupby_varname\n\t\t;\n\t%let max_lag_value = 1;\n\t%let aggregation_count = %wordcnt(&cabpblc_lag_aggregation_seq, '#');\n\t%let delay_count = %wordcnt(&cabpblc_lag_delay_seq, '#');\n\t%let cabpblc_var_count = %wordcnt(&cabpblc_var_seq, '#');\n\t%do agg_counter = 1 %to &aggregation_count;\n\t\t%let aggregation = %scan(&cabpblc_lag_aggregation_seq, &agg_counter, '#');\n\t\t%do delay_counter = 1 %to &delay_count;\n\t\t\t%let delay = %scan(&cabpblc_lag_delay_seq, &delay_counter, '#');\n\t\t\t%let temp = %sysevalf(&aggregation + &delay + 1);\n\t\t\t%if &temp > &max_lag_value %then\n\t\t\t%do;\n\t\t\t\t%let max_lag_value = &temp;\n\t\t\t%end;\n\t\t%end;\n\t%end;\n \n\t%if &cabpblc_debug_mode = 1 %then\n\t%do;\n\t\t%put INFORMATION: Max history needed for calculations &=max_lag_value;\n\t%end;\n \n\t%local\n\t\tcabpblc_temp_libname_compute\n\t\tcabpbl_output_libname\n\t\tcabpbl_output_table_name\n\t\t;\n\t%let cabpblc_temp_libname_compute = work;\n\tdata &cabpblc_temp_libname_compute.._DAFT_table_pre_agg_lag;\n\t\tset &cabpblc_input_ds;\n\t\t/* by &cabpblc_group_by; */\n\trun;\n\tproc sort\n\t\tdata = &cabpblc_temp_libname_compute.._DAFT_table_pre_agg_lag;\n\t\tby &cabpblc_group_by;\n\tquit;\n\t\n\t%let last_of_ds_groupby_varname = %scan(&cabpblc_group_by_except_time, -1);\n \n\tdata &cabpblc_temp_libname_compute.._DAFT_table_agg_by_lag ;\n\t\tset &cabpblc_temp_libname_compute.._DAFT_table_pre_agg_lag;\n\t\t\t%do counter = 1 %to &cabpblc_var_count;\n\t\t\t\t%let varname = %scan(%scan(&cabpblc_var_seq, &counter, \"#\"), 1, '$');\n\t\t\t\t&varname.L0 = &varname.;\n\t\t\t\t%do lag_counter = 1 %to &max_lag_value;\n\t\t\t\t\t&varname.L&lag_counter = lag&lag_counter(&varname.);\t\n\t\t\t\t%end;\n\t\t\t%end;\n\trun;\n\tdata &cabpblc_temp_libname_compute.._DAFT_table_agg_by_lag;\n\t\tset &cabpblc_temp_libname_compute.._DAFT_table_agg_by_lag;\n\t\tby &cabpblc_group_by_except_time;\n\t\tretain temp_counter 0;\n\t\tdrop temp_counter;\n\t\tif first.&last_of_ds_groupby_varname then\n\t\tdo;\n\t\t\ttemp_counter = 0;\n\t\tend;\n\t\ttemp_counter = temp_counter + 1;\n\t\t\t%do counter = 1 %to &cabpblc_var_count;\n\t\t\t\t%let varname = %scan(%scan(&cabpblc_var_seq, &counter, \"#\"), 1, '$');\n\t\t\t\t%do lag_counter = 1 %to &max_lag_value;\n\t\t\t\t\tif temp_counter <= &lag_counter then\t\n\t\t\t\t\tdo;\n\t\t\t\t\t\t&varname.L&lag_counter = .;\t\n\t\t\t\t\tend;\n\t\t\t\t%end;\n\t\t\t%end;\n\trun;\n \n\t%let cabpbl_output_table_name = %upcase(%scan(&cabpblc_output_ds, 2, '.'));\n\t%let cabpbl_output_libname = %scan(&cabpblc_output_ds, 1, '.');\n\t%let cabpbl_target_lib_engine = ; /* V9 or CAS */\n\tproc sql noprint;\n\t\tselect distinct(engine)\n\t\tinto :cabpbl_target_lib_engine\n\t\tfrom dictionary.libnames\n\t\twhere upcase(libname) = \"%upcase(&cabpbl_output_libname)\"\n\t\t;\n\tquit;\n \n\t%let cabpbl_target_lib_engine = %upcase(%trim(%left(&cabpbl_target_lib_engine)));\n\t%if &cabpbl_target_lib_engine = CAS %then\n\t%do;\n\t\tproc casutil;\n\t\t\tdroptable casdata = \"&cabpbl_output_table_name\" incaslib = \"&cabpbl_output_libname\" quiet;\n\t\t\tdroptable casdata = \"&cabpbl_output_table_name\" incaslib = \"&cabpbl_output_libname\" quiet;\n\t\tquit;\n\t%end;\n \n\tdata &cabpblc_output_ds ;\n\t\tset &cabpblc_temp_libname_compute.._DAFT_table_agg_by_lag;\n\t\tif _n_ > &max_lag_value;\n\t\t%if &cabpblc_debug_mode = 0 %then\n\t\t%do;\n\t\t\tdrop\n\t\t\t%do counter = 1 %to &cabpblc_var_count;\n\t\t\t\t%let varname = %scan(%scan(&cabpblc_var_seq, &counter, \"#\"), 1, '$');\n\t\t\t\t%let cabpblc_stat_function = %scan(%scan(&cabpblc_var_seq, &counter, \"#\"), 2, '$');\n\t\t\t\t&varname.L0\n\t\t\t\t%do lag_counter = 1 %to &max_lag_value;\n\t\t\t\t\t&varname.L&lag_counter \t\n\t\t\t\t%end;\n\t\t\t%end;\n\t\t\t;\n\t\t%end;\t\t \t\t\t\n\t\t%if &cabpblc_debug_mode = 1 %then\n\t\t%do;\n\t\t\t%put INFORMATION: Now processing &=aggregation_count;\n\t\t\t%put INFORMATION: Now processing &=delay_count;\n\t\t\t%put INFORMATION: Now processing &=cabpblc_lag_aggregation_seq;\n\t\t\t%put INFORMATION: Now processing &=cabpblc_lag_delay_seq;\n\t\t\t%put INFORMATION: Now processing &=cabpblc_var_count;\n\t\t\t%put INFORMATION: Now processing &=cabpblc_var_seq;\n\t\t%end;\n\t\t%do agg_counter = 1 %to &aggregation_count;\n\t\t\t%let aggregation = %scan(&cabpblc_lag_aggregation_seq, &agg_counter, '#');\n\t\t\t%do delay_counter = 1 %to &delay_count;\n\t\t\t\t%let delay = %scan(&cabpblc_lag_delay_seq, &delay_counter, '#');\n\t\t\t\t%do counter = 1 %to &cabpblc_var_count;\n\t\t\t\t\t%let varname = %scan(%scan(&cabpblc_var_seq, &counter, \"#\"), 1, '$');\n\t\t\t\t\t%let cabpblc_stat_function = %scan(%scan(&cabpblc_var_seq, &counter, \"#\"), 2, '$');\n\t\t\t\t\t%if %upcase(&cabpblc_stat_function) eq AVG %then\n\t\t\t\t\t%do;\n\t\t\t\t\t\t/* &varname._&cabpblc_stat_function.&aggregation.L&delay = mean(of &varname.L&delay-&varname.L%eval(&delay + &aggregation - 1)); */\n\t\t\t\t\t\t&varname.&aggregation.L&delay = mean(of &varname.L&delay-&varname.L%eval(&delay + &aggregation - 1));\n\t\t\t\t\t%end; %else %if %upcase(&cabpblc_stat_function) eq AGG %then\n\t\t\t\t\t%do;\n\t\t\t\t\t\t/* &varname._&cabpblc_stat_function.&aggregation.L&delay = sum(of &varname.L&delay-&varname.L%eval(&delay + &aggregation - 1)); */\n\t\t\t\t\t\t&varname.&aggregation.L&delay = sum(of &varname.L&delay-&varname.L%eval(&delay + &aggregation - 1));\n\t\t\t\t\t%end; %else %if %upcase(&cabpblc_stat_function) eq ASIS %then\n\t\t\t\t\t%do;\n\t\t\t\t\t\t&varname._L&delay = &varname.L&delay;\n\t\t\t\t\t\t&varname._L&delay = &varname.L&delay;\n\t\t\t\t\t%end; %else\n\t\t\t\t\t%do;\n\t\t\t\t\t\t/* &varname._&cabpblc_stat_function.&aggregation.L&delay = &cabpblc_stat_function.(of &varname.L&delay-&varname.L%eval(&delay + &aggregation - 1)); */\n\t\t\t\t\t\t&varname.&aggregation.L&delay = &cabpblc_stat_function.(of &varname.L&delay-&varname.L%eval(&delay + &aggregation - 1));\n\t\t\t\t\t%end;\n\t\t\t\t%end;\n\t\t\t%end;\n\t\t%end;\n\trun;\n \n \n\t%if &cabpbl_target_lib_engine = CAS %then\n\t%do;\n\t\tproc casutil;\n\t\t\tpromote casdata=\"&cabpbl_output_table_name\" incaslib=\"&cabpbl_output_libname\"\n\t\t\t\t\toutcaslib=\"&cabpbl_output_libname\" casout=\"&cabpbl_output_table_name\";\n\t\t\tsave casdata=\"&cabpbl_output_table_name\" incaslib=\"&cabpbl_output_libname\"\n\t\t\t\t\toutcaslib=\"&cabpbl_output_libname\" casout=\"&cabpbl_output_table_name\" replace;\n\t\tquit;\n\t%end;\n \n%mend create_agg_by_period_by_lag_core;\n \n/******************************************************************************\n \n%create_agg_by_period_by_lag\n________\n \nDESCRIPTION:\n \nThis program creates aggregates by time period and also by lag.\nThe resulting variables can be very helpful for forecasting and such.\n \n______________________________________________________________________________\n \nNOTES: (Initials, date, summary)\n \nstweig    \t20211102  First officially Released Version\n \n______________________________________________________________________________\n \n*******************************************************************************/\n \n%macro create_agg_by_period_by_lag(\n\tcabpbl_input_ds = ,\n\tcabpbl_output_ds = ,\n\tcabpbl_sum_vars_seq = ,\n\tcabpbl_avg_vars_seq = ,\n\tcabpbl_min_vars_seq = ,\n\tcabpbl_max_vars_seq = ,\n\tcabpbl_date_variable = ,\n\tcabpbl_time_granularity = ,\n\tcabpbl_agg_period_seq = ,\n\tcabpbl_lag_period_seq = ,\n\tcabpbl_temp_libname = work,\n\tcabpbl_entity_definition_seq = ,\n\tcabpbl_group_by = ,\n\tcabpbl_debug_mode = 0,\n\tcabpbl_keep_org_var_after_means = 0\n\t\n\t);\n \n\t%local\n\t\t cabpbl_var_seq\n\t\t cabpbl_counter\n\t\t cabpbl_temp_variable_name\n\t\t;\n\t%let cabpbl_sumvar_postfix = _sum;\n\t%let cabpbl_avgvar_postfix = _mean;\n\t%let cabpbl_minvar_postfix = _min;\n\t%let cabpbl_maxvar_postfix = _max;\n \n\t%if &cabpbl_keep_org_var_after_means = 1 %then\n\t%do;\n\t\t%let cabpbl_sumvar_postfix = ;\n\t\t%let cabpbl_avgvar_postfix = ;\n\t\t%let cabpbl_minvar_postfix = ;\n\t\t%let cabpbl_maxvar_postfix = ;\n\t\t\n \n\t%end;\n \n\t%let cabpbl_sum_vars_count = %wordcnt(&cabpbl_sum_vars_seq, \"#\");\n\t%let cabpbl_avg_vars_count = %wordcnt(&cabpbl_avg_vars_seq, \"#\");\n\t%let cabpbl_min_vars_count = %wordcnt(&cabpbl_min_vars_seq, \"#\");\n\t%let cabpbl_max_vars_count = %wordcnt(&cabpbl_max_vars_seq, \"#\");\n\t%if &cabpbl_debug_mode = 1 %then\n\t%do;\n\t\t%put INFORMATION: Now processing &=cabpbl_input_ds;\n\t\t%put INFORMATION: Now processing &=cabpbl_output_ds;\n\t\t%put INFORMATION: Now processing &=cabpbl_entity_definition_seq;\n\t\t%put INFORMATION: Now processing &=cabpbl_temp_libname;\n\t%end;\n\t%let cabpbl_var_seq = ;\n\t%do cabpbl_counter = 1 %to &cabpbl_sum_vars_count;\n\t\t%let cabpbl_temp_variable_name = %scan(&cabpbl_sum_vars_seq, &cabpbl_counter, \"#\");\n\t\t%if \"&cabpbl_var_seq\" ne \"\" %then\n\t\t%do;\n\t\t\t%let cabpbl_var_seq = &cabpbl_var_seq#&cabpbl_temp_variable_name.&cabpbl_sumvar_postfix.$agg;\t\t\t\n\t\t%end; %else\n\t\t%do;\n\t\t\t%let cabpbl_var_seq = &cabpbl_temp_variable_name.&cabpbl_sumvar_postfix.$agg;\t\t\t\n\t\t%end;\n\t%end;\n\t%do cabpbl_counter = 1 %to &cabpbl_avg_vars_count;\n\t\t%let cabpbl_temp_variable_name = %scan(&cabpbl_avg_vars_seq, &cabpbl_counter, \"#\");\n\t\t%if \"&cabpbl_var_seq\" ne \"\" %then\n\t\t%do;\n\t\t\t%let cabpbl_var_seq = &cabpbl_var_seq#&cabpbl_temp_variable_name.&cabpbl_avgvar_postfix.$avg;\t\t\t\n\t\t%end; %else\n\t\t%do;\n\t\t\t%let cabpbl_var_seq = &cabpbl_temp_variable_name.&cabpbl_avgvar_postfix.$avg;\t\t\t\n\t\t%end;\n\t%end;\n\t%do cabpbl_counter = 1 %to &cabpbl_min_vars_count;\n\t\t%let cabpbl_temp_variable_name = %scan(&cabpbl_min_vars_seq, &cabpbl_counter, \"#\");\n\t\t%if \"&cabpbl_var_seq\" ne \"\" %then\n\t\t%do;\n\t\t\t%let cabpbl_var_seq = &cabpbl_var_seq#&cabpbl_temp_variable_name.&cabpbl_minvar_postfix.$min;\t\t\t\n\t\t%end; %else\n\t\t%do;\n\t\t\t%let cabpbl_var_seq = &cabpbl_temp_variable_name.&cabpbl_minvar_postfix.$min;\t\t\t\n\t\t%end;\n\t%end;\n\t%do cabpbl_counter = 1 %to &cabpbl_max_vars_count;\n\t\t%let cabpbl_temp_variable_name = %scan(&cabpbl_max_vars_seq, &cabpbl_counter, \"#\");\n\t\t%if \"&cabpbl_var_seq\" ne \"\" %then\n\t\t%do;\n\t\t\t%let cabpbl_var_seq = &cabpbl_var_seq#&cabpbl_temp_variable_name.&cabpbl_maxvar_postfix.$max;\t\t\t\n\t\t%end; %else\n\t\t%do;\n\t\t\t%let cabpbl_var_seq = &cabpbl_temp_variable_name.&cabpbl_maxvar_postfix.$max;\t\t\t\n\t\t%end;\n\t%end;\n \n\t%if &cabpbl_debug_mode = 1 %then\n\t%do;\n\t\t%put INFORMATION: Now processing &=cabpbl_maxvar_postfix;\n\t\t%put INFORMATION: Now processing &=cabpbl_minvar_postfix;\n\t\t%put INFORMATION: Now processing &=cabpbl_sum_vars_seq;\n\t\t%put INFORMATION: Now processing &=cabpbl_avg_vars_seq;\n\t\t%put INFORMATION: Now processing &=cabpbl_entity_definition_seq;\n\t\t%put INFORMATION: Now processing &=cabpbl_lag_period_seq;\n\t\t%put INFORMATION: Now processing &=cabpbl_agg_period_seq;\n\t\t%put INFORMATION: Now processing &=cabpbl_var_seq;\n\t%end;\n\t\n\t%create_agg_by_period_by_lag_core(\n\t\tcabpblc_lag_aggregation_seq = &cabpbl_agg_period_seq,\n\t\tcabpblc_lag_delay_seq = &cabpbl_lag_period_seq,\n\t\tcabpblc_input_ds = &cabpbl_input_ds,\n\t\tcabpblc_output_ds = &cabpbl_output_ds,\n\t\tcabpblc_var_seq = &cabpbl_var_seq,\n\t\tcabpblc_debug_mode = &cabpbl_debug_mode,\n\t\tcabpblc_group_by = &cabpbl_group_by,\n\t\tcabpblc_group_by_except_time = &cabpbl_entity_definition_seq,\n\t\tcabpblc_temp_libname = &cabpbl_temp_libname\n\t\t);\n \n \n%mend create_agg_by_period_by_lag;\n \n/******************************************************************************\n \n%create_cube_by_timeunit\n________\n \n \n \n______________________________________________________________________________\n \n \nDESCRIPTION:\n \nthis program creates a cube by timeunit and by location.\n \nIt is also designed to work with a UI like the task environment.\n \n______________________________________________________________________________\n \n \nNOTES: (Initials, date, summary)\n \nstweig    \t20211102  First officially Released Version\n______________________________________________________________________________\n \n*******************************************************************************/\n \n%macro create_cube_by_timeunit(\n\tccbt_input_ds = ,\n\tccbt_output_ds = work._ccbt_DAFT_output_ds,\n\tccbt_debug_mode = 0,\n\tccbt_sum_variables_seq = ,\n\tccbt_avg_variables_seq = ,\n\tccbt_min_variables_seq = ,\n\tccbt_max_variables_seq = ,\n\tccbt_avg_variables_blk_seq = ,\n\tccbt_sum_variables_blk_seq = ,\n\tccbt_min_variables_blk_seq = ,\n\tccbt_max_variables_blk_seq = ,\n\tccbt_entity_definition_seq = ,\n\tccbt_date_variable = ,\nccbt_group_by = ,\n\tccbt_time_granularity = ,\n\tccbt_temp_libname = work,\nccbt_agg_start_year = 2015,\nccbt_agg_end_year = 2021,\n\tccbt_keep_org_var_after_means = 0\n \n);\n \n \n \n/***\ntake the weather data and prepare variables so they are congruent and standardized, e.g.\nmaking sure the date variable is standardized, etc. so it can be used later\nfor building the krons according to chosen granularity\n***/\n\tdata &ccbt_temp_libname.._DAFT_pre_cube;\n\t\tset &ccbt_input_ds;\n/*        %if %upcase(\"&ccbt_temp_libname\") eq \"PUBLIC\" %then*/\n/*        %do;*/\n/*            by &ccbt_group_by;*/\n/*        %end;*/\nkeep\n\t\t\t_DAFT_year\n\t\t\t_DAFT_&ccbt_time_granularity\n\t\t\t&ccbt_sum_variables_blk_seq\n\t\t\t&ccbt_avg_variables_blk_seq\n\t\t\t&ccbt_min_variables_blk_seq\n\t\t\t&ccbt_max_variables_blk_seq\n\t\t\t&ccbt_date_variable\n\t\t\t_DAFT_date_sas\n\t\t\t&ccbt_entity_definition_seq\n\t\t\t;\n\t\tformat _DAFT_date_sas date9.;\n\t\t/* %if &run_environment = CAS %then\n\t\t%do; */\n\t\t\t_DAFT_date_sas = &date_variable;\n\t\t/* %end; %else\n\t\t%do;\n\t\t\t_DAFT_date_sas = input(&date_variable, anydtdte10.);\n\t\t%end; */\n\t\t%if %upcase(\"&ccbt_time_granularity\") ne \"DAY\" %then\n\t\t%do;\n\t\t\t_DAFT_&ccbt_time_granularity = &ccbt_time_granularity(_DAFT_date_sas);\n\t\t%end; %else\n\t\t%do;\n\t\t\t_DAFT_&ccbt_time_granularity = mod(juldate(_DAFT_date_sas),1000);\n\t\t%end;\n\t\t_DAFT_year = year(_DAFT_date_sas);\n\t\tif _DAFT_year >= &ccbt_agg_start_year and\n\t\t\t_DAFT_year <= &ccbt_agg_end_year;\n\trun;\n \n%if %upcase(\"&ccbt_temp_libname\") ne \"PUBLIC\" %then\n%do;\n\tproc sort data = &ccbt_temp_libname.._DAFT_pre_cube;\n\t\tby &ccbt_group_by;\n\trun;\n%end;\n \n/**\nbuild normalized cube\n**/\n \n/***\ndepending on the variables chosen by topic (sum, min or max), those\naggregated values are calculated by the group_by variables.\n***/\n\t%let ccbt_sum_vars_count = %wordcnt(&ccbt_sum_variables_seq, \"#\");\n\t%let ccbt_avg_vars_count = %wordcnt(&ccbt_avg_variables_seq, \"#\");\n\t%let ccbt_min_vars_count = %wordcnt(&ccbt_min_variables_seq, \"#\");\n\t%let ccbt_max_vars_count = %wordcnt(&ccbt_max_variables_seq, \"#\");\n \n\tproc means data = &ccbt_temp_libname.._DAFT_pre_cube nolabels noprint;\n\t\tclass &ccbt_group_by;\n\t\toutput out = &ccbt_temp_libname.._DAFT_cube_base_&ccbt_time_granularity\n\t\t%if \"&ccbt_sum_variables_seq\" ne \"\" %then\n\t\t%do;\n\t\t\tsum(&ccbt_sum_variables_blk_seq)=\n\t\t%end;\n\t\t%if \"&ccbt_avg_variables_seq\" ne \"\" %then\n\t\t%do;\n\t\t\tmean(&ccbt_avg_variables_blk_seq)=\n\t\t%end;\n\t\t%if \"&ccbt_min_variables_seq\" ne \"\" %then\n\t\t%do;\n\t\t\tmin(&ccbt_min_variables_blk_seq)=\n\t\t%end;\n\t\t%if \"&ccbt_max_variables_seq\" ne \"\" %then\n\t\t%do;\n\t\t\tmax(&ccbt_max_variables_blk_seq)=\n\t\t%end;\n\t\t\t/autoname;\n\tquit;\n \n \n \n \n \n \n%let ccbt_location_count = %wordcnt(&ccbt_entity_definition_seq, \" \");\n/***\ndrop variables and rows from the means output\nthat is not needed.\n***/\n \n\tdata &ccbt_output_ds\n\t\t\t%if &ccbt_keep_org_var_after_means = 1 %then\n\t\t\t%do;\n\t\t\t(rename = (\n\t\t\t\t%do ccbt_counter = 1 %to &ccbt_sum_vars_count;\n\t\t\t\t\t%let ccbt_varname = %scan(&ccbt_sum_variables_seq, &ccbt_counter, \"#\");\n\t\t\t\t\t\t&ccbt_varname._sum = &ccbt_varname.\t\t\t\n\t\t\t\t%end;\n\t\t\t\t%do ccbt_counter = 1 %to &ccbt_avg_vars_count;\n\t\t\t\t\t%let ccbt_varname = %scan(&ccbt_avg_variables_seq, &ccbt_counter, \"#\");\n\t\t\t\t\t\t&ccbt_varname._avg = &ccbt_varname.\t\t\t\n\t\t\t\t%end;\n\t\t\t\t%do ccbt_counter = 1 %to &ccbt_min_vars_count;\n\t\t\t\t\t%let ccbt_varname = %scan(&ccbt_min_variables_seq, &ccbt_counter, \"#\");\n\t\t\t\t\t\t&ccbt_varname._min = &ccbt_varname.\t\t\t\n\t\t\t\t%end;\n\t\t\t\t%do ccbt_counter = 1 %to &ccbt_max_vars_count;\n\t\t\t\t\t%let ccbt_varname = %scan(&ccbt_max_variables_seq, &ccbt_counter, \"#\");\n\t\t\t\t\t\t&ccbt_varname._max = &ccbt_varname.\t\t\t\n\t\t\t\t%end;\t\t\n\t\t\t\t\t)\n\t\t\t)\n\t\t\t%end;\n\t\t\t;\n\t\tset &ccbt_temp_libname.._DAFT_cube_base_&ccbt_time_granularity;\n\t\tdrop\n\t\t\t_type_\n\t\t\t_freq_\n\t\t\t;\n\t\tif not missing(_DAFT_year) and\n\t\t%do ccbt_counter = 1 %to &ccbt_location_count;\n\t\t\t%let ccbt_varname = %scan(&ccbt_entity_definition_seq, &ccbt_counter, \" \");\n\t\t\tnot missing(&ccbt_varname) and\n\t\t%end;\t\t\t\n\t\t\tnot missing(_DAFT_&ccbt_time_granularity) then\n\t\tdo;\n\t\t\toutput &ccbt_output_ds;\n\t\tend;\n\trun;\n \n \n\t/* %if &upload_base_cube_to_CAS = 1 %then\n\t%do;\n\t\t%load_final_data(\n\t\t\tlfd_libname = wc_wh,\n\t\t\twof2l_final_table_name = &cube_final_datasetname_root.&ccbt_time_granularity,\n\t\t\tlfd_target_libname = &cas_target_libname,\n\t\t\tlfd_environment_macro_var_name = run_environment\n\t\t\t);\n\t%end; */\n \n \n \n%mend create_cube_by_timeunit;\n \n%macro create_clean_varname_blk_seq(\n\tccvbs_seq_name = ,\n\tccvbs_original_seq = );\n\t%let &ccvbs_seq_name = ;\n%put ccvbs_seq_name = &ccvbs_seq_name;\n%put ccvbs_original_seq = &ccvbs_original_seq;\n\t%do ccvbs_counter = 1 %to %wordcnt(&ccvbs_original_seq, \"#\");\n\t\t%let ccvbs_seq_piece = %scan(&ccvbs_original_seq, &ccvbs_counter, \"#\");\n\t\t%put &=ccvbs_seq_piece;\n\t\t%let ccvbs_pos_start = %index(&ccvbs_seq_piece, %str(%'));\n\t\t%let ccvbs_pos_end = %index(&ccvbs_seq_piece, %str(%'n));\n%put &=ccvbs_seq_piece &=ccvbs_pos_start &=ccvbs_pos_end;\n\t\t%if &ccvbs_pos_start ne 0 and\t\t\n\t\t\t&ccvbs_pos_end ne 0 %then\n\t\t%do;\n\t\t\t%let ccvbs_length_to_check = %length(&ccvbs_seq_piece);\n\t\t\t%let ccvbs_new_var_name = %sysfunc(tranwrd(%substr(&ccvbs_seq_piece, 2, %eval(&ccvbs_length_to_check -3)), %str( ), %str(_)));\n\t\t\t%let ccvbs_new_var_name = %sysfunc(tranwrd(&ccvbs_new_var_name, %str($), %str(_)));\n\t\t\t%let ccvbs_new_var_name = %sysfunc(tranwrd(&ccvbs_new_var_name, %str(%@), %str(_)));\n\t\t\t%let ccvbs_new_var_name = %sysfunc(tranwrd(&ccvbs_new_var_name, %str(%%), %str(_)));\n\t\t\t%let ccvbs_new_var_name = %sysfunc(tranwrd(&ccvbs_new_var_name, %str(%(), %str(_)));\n\t\t\t%let ccvbs_new_var_name = %sysfunc(tranwrd(&ccvbs_new_var_name, %str(%)), %str(_)));\n%put &=ccvbs_length_to_check  &=ccvbs_new_var_name;\n\t\t%end; %else\n\t\t%do;\n\t\t\t%let ccvbs_new_var_name = &ccvbs_seq_piece;\n%put  &=ccvbs_new_var_name;\n\t\t%end;\n\t\t%let &ccvbs_seq_name = &&&ccvbs_seq_name &ccvbs_new_var_name;\n\t%end;\n%mend create_clean_varname_blk_seq;\n/******************************************************************************\n \n%create_data_views_execution\n________\n \n \nThis wrapper can take any data set that is based on location variables and date and\n\tcreates aggregations by period by lag for specific time units.\n \n\tIt is also set up to create so called kron variables that give an indication how\n\ta distribution compares to a norm distributed that is calculated on the fly based on a\n\tnorm time period (e.g. 6 years)\n \n______________________________________________________________________________\n \n \n______________________________________________________________________________\n \nNOTES: (Initials, date, summary)\n \nstweig    \t20211102  First officially Released Version\n \n______________________________________________________________________________\n \n*******************************************************************************/\n \n%macro wrapper_create_lagged_aggrgtns(\n\twcla_input_ds = ,\n\twcla_output_ds = work._DAFT_output_ds,\n\twcla_run_environment = CAS,\n\twcla_debug_mode = 0,\n\twcla_sum_variables_seq = ,\n\twcla_avg_variables_seq = ,\n\twcla_min_variables_seq = ,\n\twcla_max_variables_seq = ,\n\twcla_entity_definition_seq = ,\n\twcla_date_variable = ,\n\twcla_time_granularity = ,\n\twcla_agg_period_seq = ,\n\twcla_lag_period_seq = ,\n\twcla_directory_separator = ,\n\twcla_temp_libname = work,\nwcla_agg_start_year = 2015,\nwcla_agg_end_year = 2021,\n\twcla_keep_org_var_after_means = 0\n\t);\n \n \n \n/***\nset group_by parameter for later.\n_daft_year_ variable will be created automatically\n***/\n%local\n\twcla_group_by_except_last\n\twcla_group_by_last\n\twcla_group_by\n\twcla_location_count\n\twcla_sum_vars_seq_blk\n\twcla_avg_vars_seq_blk\n\twcla_min_vars_seq_blk\n\twcla_max_vars_seq_blk\n \n \n\t;\n \n/***\nsequence information that comes in via the task UI needs to get\ncleaned up, so it is standardized and comes as a sequence separated by a blank (instead of separated by #)\nprovide the sequence name as defined in the task object and the name of the macro variable\nwhere the new standardized sequence is stored.\nIt especially deals with variable names that contain blanks.\nSo with that I have the original sequence plus a sequence with the new variable names that are separated by blanks.\nThis allows better usage downstream.\n***/\n \n%let wcla_sum_vars_seq_blk = ;\n%let wcla_avg_vars_seq_blk = ;\n%let wcla_min_vars_seq_blk = ;\n%let wcla_max_vars_seq_blk = ;\n%let wcla_ent_def_seq_blk = ;\n \n%create_clean_varname_blk_seq\n\t(\n\tccvbs_seq_name = wcla_ent_def_seq_blk,\n\tccvbs_original_seq = &wcla_entity_definition_seq\n\t);\n%create_clean_varname_blk_seq\n\t(\n\tccvbs_seq_name = wcla_sum_vars_seq_blk,\n\tccvbs_original_seq = &wcla_sum_variables_seq\n\t);\n%create_clean_varname_blk_seq\n\t(\n\tccvbs_seq_name = wcla_avg_vars_seq_blk,\n\tccvbs_original_seq = &wcla_avg_variables_seq\n\t);\n%create_clean_varname_blk_seq\n\t(\n\tccvbs_seq_name = wcla_min_vars_seq_blk,\n\tccvbs_original_seq = &wcla_min_variables_seq\n\t);\n%create_clean_varname_blk_seq\n\t(\n\tccvbs_seq_name = wcla_max_vars_seq_blk,\n\tccvbs_original_seq = &wcla_max_variables_seq\n\t);\n%let wcla_group_by_except_last = &wcla_ent_def_seq_blk _daft_year;\n%let wcla_group_by_last = _daft_&wcla_time_granularity;\n \n%let wcla_group_by = &wcla_group_by_except_last &wcla_group_by_last;\n \n%let wcla_location_count = %wordcnt(&wcla_entity_definition_seq, \" \");\n \n%if &debug_mode = 1 %then\n%do;\n\t%put INFORMATION: Now processing &=wcla_sum_variables_seq;\n\t%put INFORMATION: Now processing &=wcla_avg_variables_seq;\n\t%put INFORMATION: Now processing &=wcla_min_variables_seq;\n\t%put INFORMATION: Now processing &=wcla_max_variables_seq;\n\t%put INFORMATION: Now processing &=wcla_avg_vars_seq_blk;\n\t%put INFORMATION: Now processing &=wcla_sum_vars_seq_blk;\n\t%put INFORMATION: Now processing &=wcla_min_vars_seq_blk;\n\t%put INFORMATION: Now processing &=wcla_max_vars_seq_blk;\n\t%put INFORMATION: Now processing &=wcla_entity_definition_seq;\n\t%put INFORMATION: Now processing &=wcla_ent_def_seq_blk;\n\t%put INFORMATION: Now processing &=wcla_group_by;\n%end;\n \n \n \ndata &wcla_temp_libname.._DAFT_RAW_DATA_ADJUSTED (keep =\n\t\t&wcla_sum_vars_seq_blk\n\t\t&wcla_avg_vars_seq_blk\n\t\t&wcla_min_vars_seq_blk\n\t\t&wcla_max_vars_seq_blk\n\t\t&date_variable\n\t\t&wcla_ent_def_seq_blk\n\t\t);\n\tset &wcla_input_ds ;\n\t%do wcla_var_counter = 1 %to %wordcnt(&wcla_sum_vars_seq_blk, ' ');\n\t\t%let wcla_variable_new = %scan(&wcla_sum_vars_seq_blk, &wcla_var_counter, ' ');\n\t\t%let wcla_variable_old = %scan(&wcla_sum_variables_seq, &wcla_var_counter, \"#\");\n\t\t&wcla_variable_new = &wcla_variable_old;\n\t%end;\n\t%do wcla_var_counter = 1 %to %wordcnt(&wcla_avg_vars_seq_blk, ' ');\n\t\t%let wcla_variable_new = %scan(&wcla_avg_vars_seq_blk, &wcla_var_counter, ' ');\n\t\t%let wcla_variable_old = %scan(&wcla_avg_variables_seq, &wcla_var_counter, \"#\");\n\t\t&wcla_variable_new = &wcla_variable_old;\n\t%end;\n\t%do wcla_var_counter = 1 %to %wordcnt(&wcla_min_vars_seq_blk, ' ');\n\t\t%let wcla_variable_new = %scan(&wcla_min_vars_seq_blk, &wcla_var_counter, ' ');\n\t\t%let wcla_variable_old = %scan(&wcla_min_variables_seq, &wcla_var_counter, \"#\");\n\t\t&wcla_variable_new = &wcla_variable_old;\n\t%end;\n\t%do wcla_var_counter = 1 %to %wordcnt(&wcla_max_vars_seq_blk, ' ');\n\t\t%let wcla_variable_new = %scan(&wcla_max_vars_seq_blk, &wcla_var_counter, ' ');\n\t\t%let wcla_variable_old = %scan(&wcla_max_variables_seq, &wcla_var_counter, \"#\");\n\t\t&wcla_variable_new = &wcla_variable_old;\n\t%end;\n\t%do wcla_var_counter = 1 %to %wordcnt(&wcla_ent_def_seq_blk, ' ');\n\t\t%let wcla_variable_new = %scan(&wcla_ent_def_seq_blk, &wcla_var_counter, ' ');\n\t\t%let wcla_variable_old = %scan(&wcla_entity_definition_seq, &wcla_var_counter, \"#\");\n\t\t&wcla_variable_new = &wcla_variable_old;\n\t%end;\nrun;\n \n%let wcla_avg_vars_seq = %sysfunc(tranwrd(&wcla_avg_vars_seq_blk, %str( ), %str(#)));\n%let wcla_sum_vars_seq = %sysfunc(tranwrd(&wcla_sum_vars_seq_blk, %str( ), %str(#)));\n%let wcla_min_vars_seq = %sysfunc(tranwrd(&wcla_min_vars_seq_blk, %str( ), %str(#)));\n%let wcla_max_vars_seq = %sysfunc(tranwrd(&wcla_max_vars_seq_blk, %str( ), %str(#)));\n \n \n \n \n%create_cube_by_timeunit(\n\tccbt_input_ds = &wcla_temp_libname.._DAFT_RAW_DATA_ADJUSTED,\n\tccbt_output_ds = &wcla_temp_libname.._DAFT_cube_base_clean_&wcla_time_granularity,\n\tccbt_debug_mode = &wcla_debug_mode,\n\tccbt_sum_variables_seq = &wcla_sum_vars_seq,\n\tccbt_avg_variables_seq = &wcla_avg_vars_seq,\n\tccbt_min_variables_seq = &wcla_min_vars_seq,\n\tccbt_max_variables_seq = &wcla_max_vars_seq,\n\tccbt_avg_variables_blk_seq = &wcla_avg_vars_seq_blk,\n\tccbt_sum_variables_blk_seq = &wcla_sum_vars_seq_blk,\n\tccbt_min_variables_blk_seq = &wcla_min_vars_seq_blk,\n\tccbt_max_variables_blk_seq = &wcla_max_vars_seq_blk,\n\tccbt_entity_definition_seq = &wcla_ent_def_seq_blk,\n\tccbt_date_variable = &wcla_date_variable,\nccbt_group_by = &wcla_group_by,\n\tccbt_time_granularity = &wcla_time_granularity,\n\tccbt_temp_libname = &wcla_temp_libname,\nccbt_agg_start_year = &wcla_agg_start_year,\nccbt_agg_end_year = &wcla_agg_end_year,\n\tccbt_keep_org_var_after_means = &wcla_keep_org_var_after_means\n \n);\n/***\ndepending on the variables chosen by topic (sum, min or max), those\naggregated values are calculated by the group_by variables.\n***/\n \n%create_agg_by_period_by_lag(\n\tcabpbl_input_ds = &wcla_temp_libname.._DAFT_cube_base_clean_&wcla_time_granularity,\n\tcabpbl_output_ds = &wcla_output_ds,\n\tcabpbl_sum_vars_seq = &wcla_sum_variables_seq,\n\tcabpbl_avg_vars_seq = &wcla_avg_variables_seq,\n\tcabpbl_min_vars_seq = &wcla_min_variables_seq,\n\tcabpbl_max_vars_seq = &wcla_max_variables_seq,\n\tcabpbl_date_variable = &wcla_date_variable,\n\tcabpbl_time_granularity = &wcla_time_granularity,\n\tcabpbl_agg_period_seq = &wcla_agg_period_seq,\n\tcabpbl_lag_period_seq = &wcla_lag_period_seq,\n\tcabpbl_temp_libname = &wcla_temp_libname,\n\tcabpbl_entity_definition_seq = &wcla_ent_def_seq_blk,\n\tcabpbl_group_by = &wcla_group_by,\n\tcabpbl_debug_mode = &wcla_debug_mode,\n\tcabpbl_keep_org_var_after_means = &wcla_keep_org_var_after_means\n\t\n\t);\n \n \n%mend;\n \n%macro execute_all();\n \n%let directory_separator = /;\n%let write_log_into_file = &write_log_to_file_ui\t;\n%let provide_default_log_path = ;\n%let log_file_directory_source_ui = ;\n%if \"&log_file_path_ui\" ne \"\" %then\n%do;\n\t%let provide_default_log_path = %scan(&log_file_path_ui, 2, \":\")/;\n\t%let log_file_directory_source_ui = %scan(&log_file_path_ui, 1, \":\");\n%end;\n \n \n%let period_start_year = &period_start_year_ui;\n%let period_end_year = &period_end_year_ui;\n%let input_ds = &input_ds_ui;\n%let output_ds = &outputtable_ui;\n%let run_everything_in_CAS = &run_everything_in_CAS_ui;\n \n%let target_lib_output_ds = %scan(&output_ds, 1, '.');\n%let target_lib_engine = ; /* V9 or CAS */\nproc sql noprint;\n\tselect distinct(engine)\n\tinto :target_lib_engine\n\tfrom dictionary.libnames\n\twhere upcase(libname) = \"%upcase(&target_lib_output_ds)\"\n\t;\nquit;\n%let run_environment = CAS;\n%let debug_mode = &debug_mode_ui;\n \n%let target_lib_engine = %upcase(%trim(%left(&target_lib_engine)));\n \n \n \n%let temp_libname = Public;\n%if &run_everything_in_CAS = 0 or\n\t&target_lib_engine = V9 %then\n%do;\n\t%let temp_libname = work;\n%end;\n \n%let sum_variables_seq = ;\n%do counter = 1 %to &sum_variables_seq_ui_count;\n\t%let sum_variables_seq = &sum_variables_seq &&sum_variables_seq_ui_&counter._name.#;\n%end;\n \n%let avg_variables_seq = ;\n%do counter = 1 %to &avg_variables_seq_ui_count;\n\t%let avg_variables_seq = &avg_variables_seq &&avg_variables_seq_ui_&counter._name.#;\n%end;\n \n%let min_variables_seq = ;\n%do counter = 1 %to &min_variables_seq_ui_count;\n\t%let min_variables_seq = &min_variables_seq &&min_variables_seq_ui_&counter._name.#;\n%end;\n \n%let max_variables_seq = ;\n%do counter = 1 %to &max_variables_seq_ui_count;\n\t%let max_variables_seq = &max_variables_seq &&max_variables_seq_ui_&counter._name.#;\n%end;\n \n%let entity_definition_seq = ;\n%do counter = 1 %to &entity_def_seq_ui_count;\n\t%let entity_definition_seq = &entity_definition_seq &&entity_def_seq_ui_&counter._name.#;\n%end;\n \n%let date_variable = &date_variable_ui_1_name;\n%let time_granularity = &time_granularity_ui;\n%let agg_period_seq = &agg_period_seq_ui;\n%let lag_period_seq = &lag_period_seq_ui;\n%if &debug_mode = 1 %then\n%do;\n\t%put INFORMATION: Now processing &=target_lib_engine;\n\t%put INFORMATION: Now processing &=min_variables_seq;\n\t%put INFORMATION: Now processing &=sum_variables_seq;\n\t%put INFORMATION: Now processing &=avg_variables_seq;\n\t%put INFORMATION: Now processing &=entity_definition_seq;\n\t%put INFORMATION: Now processing &=max_variables_seq;\n%end;\n \n \n%if \"%upcase(&log_file_directory_source_ui)\" eq \"SASSERVER\" %then\n%do;\n\t%let log_file_in_SAS_Content = 0;\n%end; %else\n%do;\n\t%let log_file_in_SAS_Content = 1;\n%end;\n%let write_log_to_file = &write_log_to_file_ui;\n \n%if &write_log_to_file = 1 %then\n%do;\n \n\t/**\n\tdetermine and set todays date\n\t**/\n\tdata _null_;\n\t\ttodaysdate = today();\n\t\tyear = year(todaysdate);\n\t\tmonth = put(month(todaysdate), z2.);\n\t\tday = put(day(todaysdate), z2.);\n\t\tnowtime = time();\n\t\thour = put(hour(nowtime), z2.);\n\t\tminute = put(minute(nowtime), z2.);\n\t\tput minute;\n\t\ttimestamp = trim(left(year))||trim(left(month))||trim(left(day))||\"_\"||trim(left(hour))||trim(left(minute));\n\t\tcall symput('timestamp', timestamp);\n\trun;\n\t%let timestamp = %trim(%left(&timestamp));\n \n \n\t%if &log_file_in_SAS_Content = 1 %then\n\t%do;\n\t\tfilename logfile\n\t\t\tfilesrvc\n\t\t\tfolderpath = \"&provide_default_log_path\"\n\t\t\tfilename = \"wc_run_&timestamp.aggregations.log\";\n\t\tfilename printfl\n\t\t\tfilesrvc\n\t\t\tfolderpath = \"&provide_default_log_path\"\n\t\t\tfilename = \"wc_run_&timestamp.aggregations.out\";\n\t%end; %else\n\t%do;\n\t\tfilename logfile \"&provide_default_log_path.wc_run_&timestamp.aggregations.log\";\n\t\tfilename printfl \"&provide_default_log_path.wc_run_&timestamp.aggregations.out\";\n\t%end;\n\tproc printto\n\t\tlog=logfile new\n\t\tprint=printfl new;\n\tquit;\n%end;\n \n \n \n%wrapper_create_lagged_aggrgtns(\n\twcla_input_ds = &input_ds,\n\twcla_output_ds = &output_ds,\n\twcla_run_environment = CAS,\n\twcla_debug_mode = &debug_mode,\n\twcla_sum_variables_seq = &sum_variables_seq,\n\twcla_avg_variables_seq = &avg_variables_seq,\n\twcla_min_variables_seq = &min_variables_seq,\n\twcla_max_variables_seq = &max_variables_seq,\n\twcla_entity_definition_seq = &entity_definition_seq,\n\twcla_date_variable = &date_variable,\n\twcla_time_granularity = &time_granularity,\n\twcla_agg_period_seq = &agg_period_seq,\n\twcla_lag_period_seq = &lag_period_seq,\n\twcla_directory_separator = &directory_separator,\n\twcla_temp_libname = &temp_libname,\n\twcla_agg_start_year = &period_start_year,\n\twcla_agg_end_year = &period_end_year\n\t);\n \n \n%if &write_log_to_file = 1 %then\n%do;\n\tproc printto ;\n\tquit;\n%end;\n \n%mend;\n \n \n%execute_all();\n \ndata _null_;\n\tset _daft_option_setting_storage;\n\tcall execute(\"option \"||original_setting||\";\");\nrun;\n%if &debug_mode_ui ne 1 %then\n%do;\n\tproc datasets lib=work;\n\t\tdelete\n\t\t\t_daft_:\n\t\t\t;\n\tquit;\n%end;\noption validvarname = &_DAFT_option_validvarname_org;\n"}}
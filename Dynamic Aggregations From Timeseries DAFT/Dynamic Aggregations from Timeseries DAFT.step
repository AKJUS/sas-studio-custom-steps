{"creationTimeStamp":"2022-10-14T14:41:07.395Z","modifiedTimeStamp":"2023-05-08T20:54:48.089Z","createdBy":"Stephan.Weigandt@sas.com","modifiedBy":"Stephan.Weigandt@sas.com","name":"Dynamic Aggregations from Timeseries DAFT.step","displayName":"Dynamic Aggregations from Timeseries DAFT.step","localDisplayName":"Dynamic Aggregations from Timeseries DAFT.step","properties":{},"links":[{"method":"GET","rel":"self","href":"/dataFlows/steps/08c8140b-54bc-4db7-b643-94e8e0f7d31c","uri":"/dataFlows/steps/08c8140b-54bc-4db7-b643-94e8e0f7d31c","type":"application/vnd.sas.data.flow.step"},{"method":"GET","rel":"alternate","href":"/dataFlows/steps/08c8140b-54bc-4db7-b643-94e8e0f7d31c","uri":"/dataFlows/steps/08c8140b-54bc-4db7-b643-94e8e0f7d31c","type":"application/vnd.sas.data.flow.step.summary"},{"method":"GET","rel":"up","href":"/dataFlows/steps","uri":"/dataFlows/steps","type":"application/vnd.sas.collection","itemType":"application/vnd.sas.data.flow.step.summary"},{"method":"PUT","rel":"update","href":"/dataFlows/steps/08c8140b-54bc-4db7-b643-94e8e0f7d31c","uri":"/dataFlows/steps/08c8140b-54bc-4db7-b643-94e8e0f7d31c","type":"application/vnd.sas.data.flow.step","responseType":"application/vnd.sas.data.flow.step"},{"method":"DELETE","rel":"delete","href":"/dataFlows/steps/08c8140b-54bc-4db7-b643-94e8e0f7d31c","uri":"/dataFlows/steps/08c8140b-54bc-4db7-b643-94e8e0f7d31c"},{"method":"GET","rel":"transferExport","href":"/dataFlows/steps/08c8140b-54bc-4db7-b643-94e8e0f7d31c","uri":"/dataFlows/steps/08c8140b-54bc-4db7-b643-94e8e0f7d31c","responseType":"application/vnd.sas.transfer.object"},{"method":"PUT","rel":"transferImportUpdate","href":"/dataFlows/steps/08c8140b-54bc-4db7-b643-94e8e0f7d31c","uri":"/dataFlows/steps/08c8140b-54bc-4db7-b643-94e8e0f7d31c","type":"application/vnd.sas.transfer.object","responseType":"application/vnd.sas.summary"}],"metadataVersion":0.0,"version":2,"type":"code","flowMetadata":{"inputPorts":[{"name":"input_ds_ui","displayName":"input_ds_ui","localDisplayName":"input_ds_ui","minEntries":1,"maxEntries":1,"type":"table"}],"outputPorts":[{"name":"outputtable_ui","displayName":"outputtable_ui","localDisplayName":"outputtable_ui","minEntries":1,"maxEntries":1,"type":"table","requiresStructure":false}]},"ui":"{\n\t\"showPageContentOnly\": true,\n\t\"pages\": [\n\t\t{\n\t\t\t\"id\": \"InputData\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"Input Data\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"input_ds_ui\",\n\t\t\t\t\t\"type\": \"inputtable\",\n\t\t\t\t\t\"label\": \"Provide the Transaction table to be aggregated\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"sum_variables_seq_ui\",\n\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\"label\": \"Calculate the sum of:\",\n\t\t\t\t\t\"order\": true,\n\t\t\t\t\t\"columntype\": \"n\",\n\t\t\t\t\t\"max\": null,\n\t\t\t\t\t\"min\": null,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"table\": \"input_ds_ui\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"min_variables_seq_ui\",\n\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\"label\": \"Calculate the min of:\",\n\t\t\t\t\t\"order\": true,\n\t\t\t\t\t\"columntype\": \"n\",\n\t\t\t\t\t\"max\": null,\n\t\t\t\t\t\"min\": null,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"table\": \"input_ds_ui\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"max_variables_seq_ui\",\n\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\"label\": \"Calculate the max of:\",\n\t\t\t\t\t\"order\": true,\n\t\t\t\t\t\"columntype\": \"n\",\n\t\t\t\t\t\"max\": null,\n\t\t\t\t\t\"min\": null,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"table\": \"input_ds_ui\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"avg_variables_seq_ui\",\n\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\"label\": \"Calculate the average of :\",\n\t\t\t\t\t\"order\": true,\n\t\t\t\t\t\"columntype\": \"n\",\n\t\t\t\t\t\"max\": null,\n\t\t\t\t\t\"min\": null,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"table\": \"input_ds_ui\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"entity_def_seq_ui\",\n\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\"label\": \"Vars to define the smallest entity:\",\n\t\t\t\t\t\"order\": true,\n\t\t\t\t\t\"columntype\": \"a\",\n\t\t\t\t\t\"max\": null,\n\t\t\t\t\t\"min\": 1,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"table\": \"input_ds_ui\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"date_variable_ui\",\n\t\t\t\t\t\"type\": \"columnselector\",\n\t\t\t\t\t\"label\": \"Provide the date variable:\",\n\t\t\t\t\t\"order\": false,\n\t\t\t\t\t\"columntype\": \"n\",\n\t\t\t\t\t\"max\": 1,\n\t\t\t\t\t\"min\": 1,\n\t\t\t\t\t\"visible\": \"\",\n\t\t\t\t\t\"table\": \"input_ds_ui\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"outputdata\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"Output Data\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"outputtable_ui\",\n\t\t\t\t\t\"type\": \"outputtable\",\n\t\t\t\t\t\"label\": \"Output Table Name\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"placeholder\": \"E.g. public.output_table\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"time_granularity_ui\",\n\t\t\t\t\t\"type\": \"dropdown\",\n\t\t\t\t\t\"label\": \"Select Time Granularity:\",\n\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"day\",\n\t\t\t\t\t\t\t\"label\": \"By Day\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"week\",\n\t\t\t\t\t\t\t\"label\": \"By Week\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"month\",\n\t\t\t\t\t\t\t\"label\": \"By Month\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"quarter\",\n\t\t\t\t\t\t\t\"label\": \"By Quarter\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"processingoptions\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"Processing Options\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"agg_period_seq_ui\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Provide desired aggregation periods (separated by #, in chosen time granularity):\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"lag_period_seq_ui\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Provide desired delay/lag (separated by #, in chosen time granularity):\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"period_start_year_ui\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Aggregation Start Year:\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"period_end_year_ui\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Aggregation End Year:\",\n\t\t\t\t\t\"placeholder\": \"\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"admin\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"Admin Options\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"debug_mode_ui\",\n\t\t\t\t\t\"type\": \"radiogroup\",\n\t\t\t\t\t\"label\": \"Run in debug mode?\",\n\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"1\",\n\t\t\t\t\t\t\t\"label\": \"Yes\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"0\",\n\t\t\t\t\t\t\t\"label\": \"No\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"write_log_to_file_ui\",\n\t\t\t\t\t\"type\": \"radiogroup\",\n\t\t\t\t\t\"label\": \"Write Log into File? (\\\"Yes\\\" will open input field below for path selection)\",\n\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"1\",\n\t\t\t\t\t\t\t\"label\": \"Yes\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"0\",\n\t\t\t\t\t\t\t\"label\": \"No\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"log_file_path_ui\",\n\t\t\t\t\t\"type\": \"path\",\n\t\t\t\t\t\"label\": \"Path for logfile creation\",\n\t\t\t\t\t\"pathtype\": \"folder\",\n\t\t\t\t\t\"placeholder\": \"Select directory in SAS Server or SAS Content\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"visible\": [\n\t\t\t\t\t\t\"$write_log_to_file_ui\",\n\t\t\t\t\t\t\"=\",\n\t\t\t\t\t\t\"1\"\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"run_everything_in_CAS_ui\",\n\t\t\t\t\t\"type\": \"radiogroup\",\n\t\t\t\t\t\"label\": \"Run everything in CAS?\",\n\t\t\t\t\t\"items\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"1\",\n\t\t\t\t\t\t\t\"label\": \"Yes\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"value\": \"0\",\n\t\t\t\t\t\t\t\"label\": \"No\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"options_seq_ui\",\n\t\t\t\t\t\"type\": \"textfield\",\n\t\t\t\t\t\"label\": \"Provide options to be applied for this run (only single options allowed like mprint, nosource, etc).\",\n\t\t\t\t\t\"placeholder\": \"mprint notes source\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t\"id\": \"about\",\n\t\t\t\"type\": \"page\",\n\t\t\t\"label\": \"About\",\n\t\t\t\"children\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"text1\",\n\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\"text\": \"DAFT - Dynamic Aggregations from Timeseries\\nVersion: 2.0.2\\n\\nFor questions/feedback/ideas, please contact :\\nstephan.weigandt@sas.com\\n\\nPurpose:\\n\\nThis Custom Step enables SAS Studio Flow users to easily perform dynamic aggregations on timeseries data by the push of a button.\\n\\nWhat does dynamic exactly means?\\nLet's explain based on an example: often times the outcome of events is dependent on other events that happened in the past. So it is important to get the view on the data how something looked like e.g. 4 weeks ago/7 weeks, etc... ago. And how does it look like back then when looking at the aggregate data of 2 weeks/3 weeks, etc...\\n\\nAlso, often times it is not known which time parameters are important to look at, hence it might be important to create a whole bunch of combinations and then let the statistic decide which combination is important. \\n\\nDAFT allows to calculate an unlimited amount of combinations if necessary.\\n\\nAt this point, DAFT allows the following aggregation functions:\\n- sum \\n- mean\\n- min \\n- max\\n\\nThe aggregations are based on one of the following time units:\\n- day \\n- week\\n- month\\n- quarter\\n\\nWith time series data usually being very granular, aggregating to higher level is necessary to allow best results for analytic purposes. \\nUsually it depends on the problem which granularity to choose. \\n\\nThe output dataset is then made available based on that chosen granularity. \\n\\nExample:\\nWeather data is available on a minute basis, and the problem at hand requires to look at the data on a weekly basis and it is required to look at the summed up precipitation over 1 week and 2 weeks for both 4 weeks and 8 weeks ago. \\n\\nThe aggregation sequence that needs to be provided is: 1#2\\nThe lag sequence that needs to be provided is: 4#8\\n\\nDAFT then creates all combinations between aggregation and lag sequence and the output variables would look like:\\nprecipitation_sum1L4\\nprecipitation_sum1L8\\nprecipitation_sum2L4\\nprecipitation_sum2L8\\n\\nwith \\\"sum\\\" describing the statistic that is being looked at for that variable, and the number behind it describes the length based on the selected unit, and \\\"L\\\" describing which lag is being looked. \\n\\nSince the granularity is \\\"By Week\\\", DAFT would create the following 2 time variables:\\n_DAFT_year\\n_DAFT_week\\n\\nAdditionally the output dataset contains the variables that describe the entity. \\nIn the weather example, this could the region/county level, or zip code level, etc...\\nIn other examples, e.g. when the transaction data is e.g. bank data, the smallest entity could be person, household, company or parent company.\\n\\n\\nCopy/paste these next few lines of code into SAS Studio - SAS Program tab in order to create a test timeseries dataset for playing around:\\n*******\\ndata work.sample_aggregation_ds;\\n\\tformat \\n\\t\\tcurrent_date date9.;\\n\\tdrop\\n\\t\\tcounter;\\n\\tcurrent_date = 20084;\\n\\tcounter = 0;\\n\\t/**\\n\\tloop through weeks/days to create timeseries skeleton\\n\\t**/\\n\\tdo week = 1 to 52;\\n\\t\\tdo day = 1 to 7;\\n\\t\\t\\tcounter = counter + 1;\\n\\t\\t\\t/* \\n\\t\\t\\tthis produced precipitation will always sum up to the current week number when \\n\\t\\t\\tweekly aggregated\\n\\t\\t\\t*/\\n\\t\\t\\tprecipitation = week/7;\\n\\t\\t\\t/*\\n\\t\\t\\tthe max of temp_min will always be the current week number when weekly aggregated\\n\\t\\t\\t*/\\n\\t\\t\\ttemp_min = week - (day - 1)/week;\\n\\t\\t\\t/*\\n\\t\\t\\tthe min of temp_max will always be the current week number when weekly aggregated\\n\\t\\t\\t*/\\n\\t\\t\\ttemp_max = week + (week * (day-1))**2;\\n\\t\\t\\tcurrent_date = current_date + 1;\\n\\t\\t\\t/*\\n\\t\\t\\tcreate random entity number between 0 and 1, also create an entity number 2, for which \\n\\t\\t\\tabove rules apply for summation expectation\\n\\t\\t\\t*/\\n\\t\\t\\tentity = floor(mod(ranuni(counter)*100,2));\\n\\t\\t\\tcal_week = week(current_date);\\n\\t\\t\\toutput;\\n\\t\\t\\tentity = 2;\\n\\t\\t\\toutput;\\n\\t\\tend;\\n\\tend;\\nrun;\\n**************\",\n\t\t\t\t\t\"visible\": \"\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t],\n\t\"syntaxversion\": \"1.3.0\",\n\t\"values\": {\n\t\t\"input_ds_ui\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"sum_variables_seq_ui\": [],\n\t\t\"min_variables_seq_ui\": [],\n\t\t\"max_variables_seq_ui\": [],\n\t\t\"avg_variables_seq_ui\": [],\n\t\t\"entity_def_seq_ui\": [],\n\t\t\"date_variable_ui\": [],\n\t\t\"outputtable_ui\": {\n\t\t\t\"library\": \"\",\n\t\t\t\"table\": \"\"\n\t\t},\n\t\t\"time_granularity_ui\": {\n\t\t\t\"value\": \"month\",\n\t\t\t\"label\": \"By Month\"\n\t\t},\n\t\t\"agg_period_seq_ui\": \"1#2\",\n\t\t\"lag_period_seq_ui\": \"1#4\",\n\t\t\"period_start_year_ui\": \"2015\",\n\t\t\"period_end_year_ui\": \"2021\",\n\t\t\"debug_mode_ui\": {\n\t\t\t\"value\": \"0\",\n\t\t\t\"label\": \"No\"\n\t\t},\n\t\t\"write_log_to_file_ui\": {\n\t\t\t\"value\": \"0\",\n\t\t\t\"label\": \"No\"\n\t\t},\n\t\t\"log_file_path_ui\": \"\",\n\t\t\"run_everything_in_CAS_ui\": {\n\t\t\t\"value\": \"1\",\n\t\t\t\"label\": \"Yes\"\n\t\t},\n\t\t\"options_seq_ui\": \"\"\n\t},\n\t\"promptHierarchies\": []\n}","templates":{"SAS":"/******************************************************************************\n                                        %adjust_option_setings_controlled\n                                        ________\nHelps to maintain option changes in a program flow.\n______________________________________________________________________________\n\nUSAGE:                         %adjust_option_setings_controlled(aosc_option_seq = ,\n                                                        aosc_temp_option_storage_ds = ,\n                                                        aosc_running_mode = ,\n                                                        aosc_validvarname_setting =\n                                                        )\n______________________________________________________________________________\n\nDESCRIPTION:\n\nWhen option changes occur (only single word options allowed), then this macro\nhelps to maintain the original option setting, so at the end, the system can\nrevert back to the original settings.\n______________________________________________________________________________\n\nINPUT PARAMETERS AND KEYWORDS:\n\n    aosc_option_seq                    This can be a blank separated list of single word\n                                    SAS options (e.g. like: source, notes, etc...).\n                                    If empty nothing happens in CHANGE mode.\n    aosc_temp_option_storage_ds     provide the full dataset name (e.g. work._aosc_setting_storage)\n                                    where the original option values (of the ones that are\n                                    provided in AOSC_OPTION_SEQ) are stored.\n    aosc_running_mode                2 modes available:\n                                    CHANGE: takes settings from AOSC_OPTION_SEQ and applies\n                                            those\n                                    RESET: if AOSC_TEMP_OPTION_STORAGE_DS exists, this mode\n                                            will set options back according to content of\n                                            this dataset.\n    aosc_validvarname_setting         if not blank, validvarname will be set to the value\n                                    as provided with this parameter\n_________________________________________________________________________\n\nCALLS: none.\n______________________________________________________________________________\n\nNOTES: (Initials, date, summary)\n\nStephan Weigandt    20220922  First officially Released Version\n______________________________________________________________________________\n\n*******************************************************************************/\n\n%macro adjust_option_setings_controlled(\n    aosc_option_seq = ,\n    aosc_temp_option_storage_ds = work._aosc_temp_option_storage_ds,\n    aosc_running_mode = ,\n    aosc_validvarname_setting =\n    );\n\n\n    %if %upcase(\"&aosc_running_mode\") = \"CHANGE\" %then\n    %do;\n        data &aosc_temp_option_storage_ds;\n            length\n                new_setting $24.\n                original_setting $24.\n                new_single_setting_seq $256.\n                ;\n            new_setting = \"\";\n            original_setting = \"\";\n            new_single_setting_seq = \"\";\n            numberofsettings = 0;\n            additional_option_setting = 0;\n            if 0;\n        run;\n\n        %if \"&aosc_option_seq\" ne \"\" or\n            \"&aosc_validvarname_setting\" ne \"\" %then\n        %do;\n            data &aosc_temp_option_storage_ds;\n                length\n                    new_setting $24.\n                    original_setting $24.\n                    new_single_setting_seq $256.\n                    ;\n                new_single_setting_seq = strip(\"&aosc_option_seq\");\n                %if \"&aosc_validvarname_setting\" ne \"\" %then\n                %do;\n                    original_setting = getoption(\"validvarname\");\n                    additional_option_setting = 1;\n                    new_setting = \"&aosc_validvarname_setting\";\n                    output;\n                    call execute(\"option validvarname = \"||new_Setting||\";\");\n                %end;\n                %if \"&aosc_option_seq\" ne \"\" %then\n                %do;\n                    numberofsettings = count(new_single_setting_seq, \" \") + 1;\n                    additional_option_setting = 0;\n                    do i = 1 to numberofsettings;\n                        new_setting = \"\";\n                        new_setting = scan(new_single_setting_seq, i, \" \");\n                        if not missing(new_setting) then\n                        do;\n                            original_setting = getoption(new_setting);\n                            output;\n                            call execute(\"option \"||new_Setting||\";\");\n                        end;\n                    end;\n                %end;\n            run;\n        %end;\n    %end;\n\n    %if %upcase(\"&aosc_running_mode\") = \"RESET\" %then\n    %do;\n        %if %sysfunc(exist(&aosc_temp_option_storage_ds)) %then\n        %do;\n            data _null_;\n                set &aosc_temp_option_storage_ds;\n                if additional_option_setting = 1 then\n                do;\n                    call execute(\"option validvarname = \"||original_setting||\";\");\n                end; else\n                do;\n                    call execute(\"option \"||original_setting||\";\");\n                end;\n            run;\n        %end;\n    %end;\n%mend adjust_option_setings_controlled;\n\n/** FOR TESTING ***\noption nomprint nosource notes ;\n%let option_seq = mprint notes source;\n%let running_mode = CHANGE;\n%let validvarname_setting = any;\n\n%put PRECHANGE;\n%put VALIDVARNAME: %sysfunc(getoption(validvarname));\n%put SOURCE: %sysfunc(getoption(source));\n%put NOTES: %sysfunc(getoption(notes));\n%put MPRINT: %sysfunc(getoption(mprint));\n\n%adjust_option_setings_controlled(\n    aosc_option_seq = &option_seq,\n    aosc_running_mode = &running_mode,\n    aosc_validvarname_setting = &validvarname_setting\n    );\n\n%put POSTCHANGE;\n%put VALIDVARNAME: %sysfunc(getoption(validvarname));\n%put SOURCE: %sysfunc(getoption(source));\n%put NOTES: %sysfunc(getoption(notes));\n%put MPRINT: %sysfunc(getoption(mprint));\n\n\n%let running_mode = RESET;\n\n%adjust_option_setings_controlled(\n    aosc_running_mode = &running_mode\n    );\n\n%put POSTRESET;\n%put VALIDVARNAME: %sysfunc(getoption(validvarname));\n%put SOURCE: %sysfunc(getoption(source));\n%put NOTES: %sysfunc(getoption(notes));\n%put MPRINT: %sysfunc(getoption(mprint));\n\n\n\n*********************/\n\n/**\nstore current SAS options settings, so they can be reset\nat the end of processing\n**/\n\n\n%adjust_option_setings_controlled(\n    aosc_option_seq = &options_seq_ui,\n    aosc_running_mode = CHANGE,\n    aosc_validvarname_setting = any\n    );\n\n%let daft_delimiter = ;\n%macro set_os_dependent_values(\n    sodv_delimiter = daft_delimiter\n    );\n    %if %upcase(&SYSSCP) = WIN %then\n    %do;\n        %let &sodv_delimiter = \\;\n    %end; %else\n    %do;\n        %let &sodv_delimiter = /;\n    %end;\n%mend set_os_dependent_values;\n%set_os_dependent_values(\n    sodv_delimiter = daft_delimiter\n    );\n\n\n/******************************************************************************\n                                        %wordcnt\n                                        ________\nCounts the words in a list\n______________________________________________________________________________\n\nUSAGE:                         %wordcnt(list,delim)\n______________________________________________________________________________\n\nDESCRIPTION:\n\nFinds the number of words/tokens in a string.  The user specifies a\ndelimiter e.g. # to identify what separates the words.  The macro should be\ncalled in the following way:\ne.g. %let x=%wordcnt(item1#item2 item2a#item3, '#').\nAfter running the macro x will be assigned the value of wordcnt.\n______________________________________________________________________________\n\nINPUT PARAMETERS AND KEYWORDS:\n\n  list            the name of the string.\n  delim           the delimiter e.g. '#'.\n_________________________________________________________________________\n\nCALLS: none.\n______________________________________________________________________________\n\nNOTES: (Initials, date, summary)\n\nStephan Weigandt    20200406  First officially Released Version\n______________________________________________________________________________\n\n*******************************************************************************/\n%macro wordcnt(\n    list,\n    delim\n    )\n    ;\n    %local\n        word\n        wc_count;\n    %let wc_count = 0;\n    %if %quote(&list) ne %then\n    %do;\n        %let word = %scan(%quote(&list), 1, &delim);\n        %let word = %quote(&word);\n        %do %while (&word ne);\n            %let wc_count = %eval(&wc_count + 1);\n            %let word = %scan(%quote(&list), &wc_count+1, &delim);\n            %let word = %quote(&word);\n        %end;\n    %end;\n    &wc_count\n%mend wordcnt;\n/** FOR TESTING ***\noption mprint source notes ;\n%let item_seq = a b c#d$f g #h#i$j;\n%let separator = '$' ;\n%let separator = '#' ;\n%let separator = ' ' ;\n%let number_of_items = %wordcnt(&item_seq, &separator);\n%put &=number_of_items;\n\n*********************/\n%macro load_final_data(\n    lfd_libname = ,\n    wof2l_final_table_name = ,\n    lfd_target_libname = bttrball,\n    lfd_environment_macro_var_name = run_environment\n    );\n    %let wof2l_final_table_name = %upcase(&wof2l_final_table_name);\n    %if &&&lfd_environment_macro_var_name = CAS %then\n    %do;\n        proc casutil;\n            droptable casdata = \"&wof2l_final_table_name\"\n                        incaslib = \"&lfd_target_libname\" quiet;\n            droptable casdata = \"&wof2l_final_table_name\"\n                        incaslib = \"&lfd_target_libname\" quiet;\n        quit;\n    %end;\n        data &lfd_target_libname..&wof2l_final_table_name;\n            set &lfd_libname..&wof2l_final_table_name;\n        run;\n    %if &&&lfd_environment_macro_var_name = CAS %then\n    %do;\n        proc casutil;\n            promote casdata=\"&wof2l_final_table_name\"\n                    incaslib=\"&lfd_target_libname\"\n                    outcaslib=\"&lfd_target_libname\"\n                    casout=\"&wof2l_final_table_name\";\n            save casdata=\"&wof2l_final_table_name\"\n                    incaslib=\"&lfd_target_libname\"\n                    outcaslib=\"&lfd_target_libname\"\n                    casout=\"&wof2l_final_table_name\" replace;\n        quit;\n\n    %end;\n%mend load_final_data;\n/******************************************************************************\n\n                                    %create_agg_by_period_by_lag\n                                                ________\n\nDESCRIPTION:\n\n  This program creates aggregates by time period and also by lag.\n  The resulting variables can be very helpful for forecasting and such.\n______________________________________________________________________________\n\nNOTES: (Initials, date, summary)\n\nstweig        20211102  First officially Released Version\n______________________________________________________________________________\n\n*******************************************************************************/\n\n%macro create_agg_by_period_by_lag_core(\n    cabpblc_lag_aggregation_seq = ,\n    cabpblc_lag_delay_seq = ,\n    cabpblc_input_ds = ,\n    cabpblc_output_ds = ,\n    cabpblc_var_seq = ,\n    cabpblc_debug_mode = 0,\n    cabpblc_group_by = ,\n    cabpblc_group_by_except_time = ,\n    cabpblc_temp_libname = work\n    );\n    %local\n        max_lag_value\n        aggregation_count\n        delay_count\n        agg_counter\n        aggregation\n        delay_counter\n        counter\n        varname\n        cabpbl_target_lib_engine\n        run_environment\n        last_of_ds_groupby_varname\n        ;\n    %let max_lag_value = 1;\n    %let aggregation_count = %wordcnt(&cabpblc_lag_aggregation_seq, '#');\n    %let delay_count = %wordcnt(&cabpblc_lag_delay_seq, '#');\n    %let cabpblc_var_count = %wordcnt(&cabpblc_var_seq, '#');\n    %do agg_counter = 1 %to &aggregation_count;\n        %let aggregation = %scan(&cabpblc_lag_aggregation_seq,\n                                    &agg_counter,\n                                    '#');\n        %do delay_counter = 1 %to &delay_count;\n            %let delay = %scan(&cabpblc_lag_delay_seq, &delay_counter, '#');\n            %let temp = %sysevalf(&aggregation + &delay + 1);\n            %if &temp > &max_lag_value %then\n            %do;\n                %let max_lag_value = &temp;\n            %end;\n        %end;\n    %end;\n\n    %if &cabpblc_debug_mode = 1 %then\n    %do;\n        %put INFORMATION: Max history needed for calculations &=max_lag_value;\n    %end;\n\n    %local\n        cabpblc_temp_libname_compute\n        cabpbl_output_libname\n        cabpbl_output_table_name\n        ;\n    %let cabpblc_temp_libname_compute = work;\n    data &cabpblc_temp_libname_compute.._DAFT_table_pre_agg_lag;\n        set &cabpblc_input_ds;\n        /* by &cabpblc_group_by; */\n    run;\n    proc sort\n        data = &cabpblc_temp_libname_compute.._DAFT_table_pre_agg_lag;\n        by &cabpblc_group_by;\n    quit;\n\n    %let last_of_ds_groupby_varname = %scan(&cabpblc_group_by_except_time, -1);\n\n    data &cabpblc_temp_libname_compute.._DAFT_table_agg_by_lag ;\n        set &cabpblc_temp_libname_compute.._DAFT_table_pre_agg_lag;\n            %do counter = 1 %to &cabpblc_var_count;\n                %let varname = %scan(%scan(&cabpblc_var_seq,\n                                            &counter,\n                                            \"#\"),\n                                        1,\n                                        '$');\n                &varname.L0 = &varname.;\n                %do lag_counter = 1 %to &max_lag_value;\n                    &varname.L&lag_counter = lag&lag_counter(&varname.);\n                %end;\n            %end;\n    run;\n    data &cabpblc_temp_libname_compute.._DAFT_table_agg_by_lag;\n        set &cabpblc_temp_libname_compute.._DAFT_table_agg_by_lag;\n        by &cabpblc_group_by_except_time;\n        retain temp_counter 0;\n        drop temp_counter;\n        if first.&last_of_ds_groupby_varname then\n        do;\n            temp_counter = 0;\n        end;\n        temp_counter = temp_counter + 1;\n            %do counter = 1 %to &cabpblc_var_count;\n                %let varname = %scan(%scan(&cabpblc_var_seq,\n                                            &counter,\n                                            \"#\"),\n                                        1,\n                                        '$');\n                %do lag_counter = 1 %to &max_lag_value;\n                    if temp_counter <= &lag_counter then\n                    do;\n                        &varname.L&lag_counter = .;\n                    end;\n                %end;\n            %end;\n    run;\n\n    %let cabpbl_output_table_name = %upcase(%scan(&cabpblc_output_ds, 2, '.'));\n    %let cabpbl_output_libname = %scan(&cabpblc_output_ds, 1, '.');\n    %let cabpbl_target_lib_engine = ; /* V9 or CAS */\n    proc sql noprint;\n        select distinct(engine)\n        into :cabpbl_target_lib_engine\n        from dictionary.libnames\n        where upcase(libname) = \"%upcase(&cabpbl_output_libname)\"\n        ;\n    quit;\n\n    %let cabpbl_target_lib_engine = %upcase(%trim(\n                                        %left(&cabpbl_target_lib_engine)\n                                        ));\n    %if &cabpbl_target_lib_engine = CAS %then\n    %do;\n        proc casutil;\n            droptable     casdata = \"&cabpbl_output_table_name\"\n                        incaslib = \"&cabpbl_output_libname\" quiet;\n            droptable     casdata = \"&cabpbl_output_table_name\"\n                        incaslib = \"&cabpbl_output_libname\" quiet;\n        quit;\n    %end;\n\n    data &cabpblc_output_ds ;\n        set &cabpblc_temp_libname_compute.._DAFT_table_agg_by_lag;\n        if _n_ > &max_lag_value;\n        %if &cabpblc_debug_mode = 0 %then\n        %do;\n            drop\n            %do counter = 1 %to &cabpblc_var_count;\n                %let varname = %scan(%scan(&cabpblc_var_seq,\n                                            &counter,\n                                            \"#\"),\n                                        1,\n                                        '$');\n                %let cabpblc_stat_function = %scan(%scan(&cabpblc_var_seq,\n                                                            &counter,\n                                                            \"#\"),\n                                                        2,\n                                                        '$');\n                &varname.\n                &varname.L0\n                %do lag_counter = 1 %to &max_lag_value;\n                    &varname.L&lag_counter\n                %end;\n            %end;\n            ;\n        %end;\n        %if &cabpblc_debug_mode = 1 %then\n        %do;\n            %put INFORMATION: Now processing &=aggregation_count;\n            %put INFORMATION: Now processing &=delay_count;\n            %put INFORMATION: Now processing &=cabpblc_lag_aggregation_seq;\n            %put INFORMATION: Now processing &=cabpblc_lag_delay_seq;\n            %put INFORMATION: Now processing &=cabpblc_var_count;\n            %put INFORMATION: Now processing &=cabpblc_var_seq;\n        %end;\n        %do agg_counter = 1 %to &aggregation_count;\n            %let aggregation = %scan(&cabpblc_lag_aggregation_seq,\n                                        &agg_counter,\n                                        '#');\n            %do delay_counter = 1 %to &delay_count;\n                %let delay = %scan(&cabpblc_lag_delay_seq, &delay_counter, '#');\n                %do counter = 1 %to &cabpblc_var_count;\n                    %let varname = %scan(%scan(&cabpblc_var_seq,\n                                                &counter,\n                                                \"#\"),\n                                            1,\n                                            '$');\n                    %let cabpblc_stat_function = %scan(%scan(&cabpblc_var_seq,\n                                                                &counter,\n                                                                \"#\"),\n                                                            2,\n                                                            '$');\n                    %if %upcase(&cabpblc_stat_function) eq AVG %then\n                    %do;\n                        &varname.&aggregation.L&delay=mean(of &varname.L&delay-\n                                    &varname.L%eval(&delay + &aggregation - 1));\n                    %end; %else %if %upcase(&cabpblc_stat_function) eq AGG %then\n                    %do;\n                        &varname.&aggregation.L&delay = sum(of &varname.L&delay-\n                                    &varname.L%eval(&delay + &aggregation - 1));\n                    %end; %else\n                    %if %upcase(&cabpblc_stat_function) eq ASIS %then\n                    %do;\n                        &varname._L&delay = &varname.L&delay;\n                        &varname._L&delay = &varname.L&delay;\n                    %end; %else\n                    %do;\n                        &varname.&aggregation.L&delay=&cabpblc_stat_function.(of\n                                    &varname.L&delay-\n                                    &varname.L%eval(&delay + &aggregation - 1));\n                    %end;\n                %end;\n            %end;\n        %end;\n    run;\n\n\n    %if &cabpbl_target_lib_engine = CAS %then\n    %do;\n        proc casutil;\n            promote casdata=\"&cabpbl_output_table_name\"\n                    incaslib=\"&cabpbl_output_libname\"\n                    outcaslib=\"&cabpbl_output_libname\"\n                    casout=\"&cabpbl_output_table_name\";\n            save     casdata=\"&cabpbl_output_table_name\"\n                    incaslib=\"&cabpbl_output_libname\"\n                    outcaslib=\"&cabpbl_output_libname\"\n                    casout=\"&cabpbl_output_table_name\" replace;\n        quit;\n    %end;\n\n%mend create_agg_by_period_by_lag_core;\n\n/******************************************************************************\n\n                                    %create_agg_by_period_by_lag\n                                                ________\n\nDESCRIPTION:\n\n  This program creates aggregates by time period and also by lag.\n  The resulting variables can be very helpful for forecasting and such.\n\n______________________________________________________________________________\n\nNOTES: (Initials, date, summary)\n\nstweig        20211102  First officially Released Version\n\n*******************************************************************************/\n\n%macro create_agg_by_period_by_lag(\n    cabpbl_input_ds = ,\n    cabpbl_output_ds = ,\n    cabpbl_sum_vars_seq = ,\n    cabpbl_avg_vars_seq = ,\n    cabpbl_min_vars_seq = ,\n    cabpbl_max_vars_seq = ,\n    cabpbl_date_variable = ,\n    cabpbl_time_granularity = ,\n    cabpbl_agg_period_seq = ,\n    cabpbl_lag_period_seq = ,\n    cabpbl_temp_libname = work,\n    cabpbl_entity_definition_seq = ,\n    cabpbl_group_by = ,\n    cabpbl_debug_mode = 0,\n    cabpbl_keep_org_var_after_means = 0\n\n    );\n\n    %local\n        cabpbl_var_seq\n        cabpbl_counter\n        cabpbl_temp_variable_name\n        ;\n    %let cabpbl_sumvar_postfix = _sum;\n    %let cabpbl_avgvar_postfix = _mean;\n    %let cabpbl_minvar_postfix = _min;\n    %let cabpbl_maxvar_postfix = _max;\n\n    %if &cabpbl_keep_org_var_after_means = 1 %then\n    %do;\n        %let cabpbl_sumvar_postfix = ;\n        %let cabpbl_avgvar_postfix = ;\n        %let cabpbl_minvar_postfix = ;\n        %let cabpbl_maxvar_postfix = ;\n    %end;\n\n    %let cabpbl_sum_vars_count = %wordcnt(&cabpbl_sum_vars_seq, \"#\");\n    %let cabpbl_avg_vars_count = %wordcnt(&cabpbl_avg_vars_seq, \"#\");\n    %let cabpbl_min_vars_count = %wordcnt(&cabpbl_min_vars_seq, \"#\");\n    %let cabpbl_max_vars_count = %wordcnt(&cabpbl_max_vars_seq, \"#\");\n    %if &cabpbl_debug_mode = 1 %then\n    %do;\n        %put INFORMATION: Now processing &=cabpbl_input_ds;\n        %put INFORMATION: Now processing &=cabpbl_output_ds;\n        %put INFORMATION: Now processing &=cabpbl_entity_definition_seq;\n        %put INFORMATION: Now processing &=cabpbl_temp_libname;\n    %end;\n    %let cabpbl_var_seq = ;\n    %do cabpbl_counter = 1 %to &cabpbl_sum_vars_count;\n        %let cabpbl_temp_variable_name = %scan(&cabpbl_sum_vars_seq,\n                                                &cabpbl_counter,\n                                                \"#\");\n        %if \"&cabpbl_var_seq\" ne \"\" %then\n        %do;\n            %let cabpbl_var_seq = &cabpbl_var_seq#&cabpbl_temp_variable_name.&cabpbl_sumvar_postfix.$agg;\n        %end; %else\n        %do;\n            %let cabpbl_var_seq = &cabpbl_temp_variable_name.&cabpbl_sumvar_postfix.$agg;\n        %end;\n    %end;\n    %do cabpbl_counter = 1 %to &cabpbl_avg_vars_count;\n        %let cabpbl_temp_variable_name = %scan(&cabpbl_avg_vars_seq,\n                                                &cabpbl_counter,\n                                                \"#\");\n        %if \"&cabpbl_var_seq\" ne \"\" %then\n        %do;\n            %let cabpbl_var_seq = &cabpbl_var_seq#&cabpbl_temp_variable_name.&cabpbl_avgvar_postfix.$avg;\n        %end; %else\n        %do;\n            %let cabpbl_var_seq = &cabpbl_temp_variable_name.&cabpbl_avgvar_postfix.$avg;\n        %end;\n    %end;\n    %do cabpbl_counter = 1 %to &cabpbl_min_vars_count;\n        %let cabpbl_temp_variable_name = %scan(&cabpbl_min_vars_seq,\n                                                &cabpbl_counter,\n                                                \"#\");\n        %if \"&cabpbl_var_seq\" ne \"\" %then\n        %do;\n            %let cabpbl_var_seq = &cabpbl_var_seq#&cabpbl_temp_variable_name.&cabpbl_minvar_postfix.$min;\n        %end; %else\n        %do;\n            %let cabpbl_var_seq = &cabpbl_temp_variable_name.&cabpbl_minvar_postfix.$min;\n        %end;\n    %end;\n    %do cabpbl_counter = 1 %to &cabpbl_max_vars_count;\n        %let cabpbl_temp_variable_name = %scan(&cabpbl_max_vars_seq,\n                                                &cabpbl_counter,\n                                                \"#\");\n        %if \"&cabpbl_var_seq\" ne \"\" %then\n        %do;\n            %let cabpbl_var_seq = &cabpbl_var_seq#&cabpbl_temp_variable_name.&cabpbl_maxvar_postfix.$max;\n        %end; %else\n        %do;\n            %let cabpbl_var_seq = &cabpbl_temp_variable_name.&cabpbl_maxvar_postfix.$max;\n        %end;\n    %end;\n\n    %if &cabpbl_debug_mode = 1 %then\n    %do;\n        %put INFORMATION: Now processing &=cabpbl_maxvar_postfix;\n        %put INFORMATION: Now processing &=cabpbl_minvar_postfix;\n        %put INFORMATION: Now processing &=cabpbl_sum_vars_seq;\n        %put INFORMATION: Now processing &=cabpbl_avg_vars_seq;\n        %put INFORMATION: Now processing &=cabpbl_entity_definition_seq;\n        %put INFORMATION: Now processing &=cabpbl_lag_period_seq;\n        %put INFORMATION: Now processing &=cabpbl_agg_period_seq;\n        %put INFORMATION: Now processing &=cabpbl_var_seq;\n    %end;\n\n    %create_agg_by_period_by_lag_core(\n        cabpblc_lag_aggregation_seq = &cabpbl_agg_period_seq,\n        cabpblc_lag_delay_seq = &cabpbl_lag_period_seq,\n        cabpblc_input_ds = &cabpbl_input_ds,\n        cabpblc_output_ds = &cabpbl_output_ds,\n        cabpblc_var_seq = &cabpbl_var_seq,\n        cabpblc_debug_mode = &cabpbl_debug_mode,\n        cabpblc_group_by = &cabpbl_group_by,\n        cabpblc_group_by_except_time = &cabpbl_entity_definition_seq,\n        cabpblc_temp_libname = &cabpbl_temp_libname\n        );\n\n\n%mend create_agg_by_period_by_lag;\n\n/******************************************************************************\n\n                                        %create_cube_by_timeunit\n                                                ________\n\n\n\n______________________________________________________________________________\n\n\nDESCRIPTION:\n\n  this program creates a cube by timeunit and by location.\n\n  It is also designed to work with a UI like the task environment.\n\n______________________________________________________________________________\n\n\nNOTES: (Initials, date, summary)\n\nstweig        20211102  First officially Released Version\n______________________________________________________________________________\n\n*******************************************************************************/\n\n%macro create_cube_by_timeunit(\n    ccbt_input_ds = ,\n    ccbt_output_ds = work._ccbt_DAFT_output_ds,\n    ccbt_debug_mode = 0,\n    ccbt_sum_variables_seq = ,\n    ccbt_avg_variables_seq = ,\n    ccbt_min_variables_seq = ,\n    ccbt_max_variables_seq = ,\n    ccbt_avg_variables_blk_seq = ,\n    ccbt_sum_variables_blk_seq = ,\n    ccbt_min_variables_blk_seq = ,\n    ccbt_max_variables_blk_seq = ,\n    ccbt_entity_definition_seq = ,\n    ccbt_date_variable = ,\n    ccbt_group_by = ,\n    ccbt_time_granularity = ,\n    ccbt_temp_libname = work,\n    ccbt_agg_start_year = 2015,\n    ccbt_agg_end_year = 2021,\n    ccbt_keep_org_var_after_means = 0\n\n    );\n\n\n\n/***\ntake the weather data and prepare variables\nso they are congruent and standardized, e.g.\nmaking sure the date variable is standardized, etc. so it can be used later\nfor building the krons according to chosen granularity\n***/\n    data &ccbt_temp_libname.._DAFT_pre_cube;\n        set &ccbt_input_ds;\n/*        %if %upcase(\"&ccbt_temp_libname\") eq \"PUBLIC\" %then*/\n/*        %do;*/\n/*            by &ccbt_group_by;*/\n/*        %end;*/\n        keep\n            _DAFT_year\n            _DAFT_&ccbt_time_granularity\n            &ccbt_sum_variables_blk_seq\n            &ccbt_avg_variables_blk_seq\n            &ccbt_min_variables_blk_seq\n            &ccbt_max_variables_blk_seq\n            &ccbt_date_variable\n            _DAFT_date_sas\n            &ccbt_entity_definition_seq\n            ;\n        format _DAFT_date_sas date9.;\n        /* %if &run_environment = CAS %then\n        %do; */\n            _DAFT_date_sas = &date_variable;\n        /* %end; %else\n        %do;\n            _DAFT_date_sas = input(&date_variable, anydtdte10.);\n        %end; */\n        %if %upcase(\"&ccbt_time_granularity\") ne \"DAY\" %then\n        %do;\n            _DAFT_&ccbt_time_granularity=&ccbt_time_granularity(_DAFT_date_sas);\n        %end; %else\n        %do;\n            _DAFT_&ccbt_time_granularity = mod(juldate(_DAFT_date_sas),1000);\n        %end;\n        _DAFT_year = year(_DAFT_date_sas);\n        if _DAFT_year >= &ccbt_agg_start_year and\n            _DAFT_year <= &ccbt_agg_end_year;\n    run;\n\n%if %upcase(\"&ccbt_temp_libname\") ne \"PUBLIC\" %then\n%do;\n    proc sort data = &ccbt_temp_libname.._DAFT_pre_cube;\n        by &ccbt_group_by;\n    run;\n%end;\n\n/**\nbuild normalized cube\n**/\n\n/***\ndepending on the variables chosen by topic (sum, min or max), those\naggregated values are calculated by the group_by variables.\n***/\n    %let ccbt_sum_vars_count = %wordcnt(&ccbt_sum_variables_seq, \"#\");\n    %let ccbt_avg_vars_count = %wordcnt(&ccbt_avg_variables_seq, \"#\");\n    %let ccbt_min_vars_count = %wordcnt(&ccbt_min_variables_seq, \"#\");\n    %let ccbt_max_vars_count = %wordcnt(&ccbt_max_variables_seq, \"#\");\n\n    proc means data = &ccbt_temp_libname.._DAFT_pre_cube nolabels noprint;\n        class &ccbt_group_by;\n        output out = &ccbt_temp_libname.._DAFT_cube_base_&ccbt_time_granularity\n        %if \"&ccbt_sum_variables_seq\" ne \"\" %then\n        %do;\n            sum(&ccbt_sum_variables_blk_seq)=\n        %end;\n        %if \"&ccbt_avg_variables_seq\" ne \"\" %then\n        %do;\n            mean(&ccbt_avg_variables_blk_seq)=\n        %end;\n        %if \"&ccbt_min_variables_seq\" ne \"\" %then\n        %do;\n            min(&ccbt_min_variables_blk_seq)=\n        %end;\n        %if \"&ccbt_max_variables_seq\" ne \"\" %then\n        %do;\n            max(&ccbt_max_variables_blk_seq)=\n        %end;\n            /autoname;\n    quit;\n\n\n\n\n\n\n%let ccbt_location_count = %wordcnt(&ccbt_entity_definition_seq, \" \");\n/***\ndrop variables and rows from the means output\nthat is not needed.\n***/\n\n    data &ccbt_output_ds\n            %if &ccbt_keep_org_var_after_means = 1 %then\n            %do;\n            (rename = (\n                %do ccbt_counter = 1 %to &ccbt_sum_vars_count;\n                    %let ccbt_varname = %scan(&ccbt_sum_variables_seq,\n                                                &ccbt_counter,\n                                                \"#\");\n                        &ccbt_varname._sum = &ccbt_varname.\n                %end;\n                %do ccbt_counter = 1 %to &ccbt_avg_vars_count;\n                    %let ccbt_varname = %scan(&ccbt_avg_variables_seq,\n                                                &ccbt_counter,\n                                                \"#\");\n                        &ccbt_varname._avg = &ccbt_varname.\n                %end;\n                %do ccbt_counter = 1 %to &ccbt_min_vars_count;\n                    %let ccbt_varname = %scan(&ccbt_min_variables_seq,\n                                                &ccbt_counter,\n                                                \"#\");\n                        &ccbt_varname._min = &ccbt_varname.\n                %end;\n                %do ccbt_counter = 1 %to &ccbt_max_vars_count;\n                    %let ccbt_varname = %scan(&ccbt_max_variables_seq,\n                                                &ccbt_counter,\n                                                \"#\");\n                        &ccbt_varname._max = &ccbt_varname.\n                %end;\n                    )\n            )\n            %end;\n            ;\n        set &ccbt_temp_libname.._DAFT_cube_base_&ccbt_time_granularity;\n        drop\n            _type_\n            _freq_\n            ;\n        if not missing(_DAFT_year) and\n        %do ccbt_counter = 1 %to &ccbt_location_count;\n            %let ccbt_varname = %scan(&ccbt_entity_definition_seq,\n                                        &ccbt_counter,\n                                        \" \");\n            not missing(&ccbt_varname) and\n        %end;\n            not missing(_DAFT_&ccbt_time_granularity) then\n        do;\n            output &ccbt_output_ds;\n        end;\n    run;\n\n\n\n%mend create_cube_by_timeunit;\n\n%macro create_clean_varname_blk_seq(\n    ccvbs_seq_name = ,\n    ccvbs_original_seq = );\n    %let &ccvbs_seq_name = ;\n%put ccvbs_seq_name = &ccvbs_seq_name;\n%put ccvbs_original_seq = &ccvbs_original_seq;\n    %do ccvbs_counter = 1 %to %wordcnt(&ccvbs_original_seq, \"#\");\n        %let ccvbs_seq_piece = %scan(&ccvbs_original_seq, &ccvbs_counter, \"#\");\n        %put &=ccvbs_seq_piece;\n        %let ccvbs_pos_start = %index(&ccvbs_seq_piece, %str(%'));\n        %let ccvbs_pos_end = %index(&ccvbs_seq_piece, %str(%'n));\n%put &=ccvbs_seq_piece &=ccvbs_pos_start &=ccvbs_pos_end;\n        %if &ccvbs_pos_start ne 0 and\n            &ccvbs_pos_end ne 0 %then\n        %do;\n            %let ccvbs_length_to_check = %length(&ccvbs_seq_piece);\n            %let ccvbs_new_var_name = %sysfunc(tranwrd(%substr(&ccvbs_seq_piece,\n                                                                2,\n                                                                %eval(&ccvbs_length_to_check-3)),\n                                                                %str( ),\n                                                                %str(_)));\n            %let ccvbs_new_var_name = %sysfunc(tranwrd(&ccvbs_new_var_name,\n                                                        %str($),\n                                                        %str(_)));\n            %let ccvbs_new_var_name = %sysfunc(tranwrd(&ccvbs_new_var_name,\n                                                        %str(%@),\n                                                        %str(_)));\n            %let ccvbs_new_var_name = %sysfunc(tranwrd(&ccvbs_new_var_name,\n                                                        %str(%%),\n                                                        %str(_)));\n            %let ccvbs_new_var_name = %sysfunc(tranwrd(&ccvbs_new_var_name,\n                                                        %str(%(),\n                                                        %str(_)));\n            %let ccvbs_new_var_name = %sysfunc(tranwrd(&ccvbs_new_var_name,\n                                                        %str(%)),\n                                                        %str(_)));\n%put &=ccvbs_length_to_check  &=ccvbs_new_var_name;\n        %end; %else\n        %do;\n            %let ccvbs_new_var_name = &ccvbs_seq_piece;\n%put  &=ccvbs_new_var_name;\n        %end;\n        %let &ccvbs_seq_name = &&&ccvbs_seq_name &ccvbs_new_var_name;\n    %end;\n%mend create_clean_varname_blk_seq;\n/******************************************************************************\n\n                                    %create_data_views_execution\n                                            ________\n\n\nThis wrapper can take any data set that is based on location variables\nand date and creates aggregations by period by lag for specific time units.\n\nIt is also set up to create so called kron variables that give an indication how\na distribution compares to a norm distributed that is calculated\non the fly based on a norm time period (e.g. 6 years).\n\n______________________________________________________________________________\n\n\n______________________________________________________________________________\n\nNOTES: (Initials, date, summary)\n\nstweig        20211102  First officially Released Version\n\n______________________________________________________________________________\n\n*******************************************************************************/\n\n%macro wrapper_create_lagged_aggrgtns(\n    wcla_input_ds = ,\n    wcla_output_ds = work._DAFT_output_ds,\n    wcla_run_environment = CAS,\n    wcla_debug_mode = 0,\n    wcla_sum_variables_seq = ,\n    wcla_avg_variables_seq = ,\n    wcla_min_variables_seq = ,\n    wcla_max_variables_seq = ,\n    wcla_entity_definition_seq = ,\n    wcla_date_variable = ,\n    wcla_time_granularity = ,\n    wcla_agg_period_seq = ,\n    wcla_lag_period_seq = ,\n    wcla_directory_separator = ,\n    wcla_temp_libname = work,\n    wcla_agg_start_year = 2015,\n    wcla_agg_end_year = 2021,\n    wcla_keep_org_var_after_means = 0\n    );\n\n\n\n/***\nset group_by parameter for later.\n_daft_year_ variable will be created automatically\n***/\n%local\n    wcla_group_by_except_last\n    wcla_group_by_last\n    wcla_group_by\n    wcla_location_count\n    wcla_sum_vars_seq_blk\n    wcla_avg_vars_seq_blk\n    wcla_min_vars_seq_blk\n    wcla_max_vars_seq_blk\n\n\n    ;\n\n/***\nsequence information that comes in via the task UI needs to get\ncleaned up, so it is standardized and comes as a sequence separated\nby a blank (instead of separated by #)\nprovide the sequence name as defined in the task object\nand the name of the macro variable\nwhere the new standardized sequence is stored.\nIt especially deals with variable names that contain blanks.\nSo with that I have the original sequence plus a sequence with\nthe new variable names that are separated by blanks.\nThis allows better usage downstream.\n***/\n\n%let wcla_sum_vars_seq_blk = ;\n%let wcla_avg_vars_seq_blk = ;\n%let wcla_min_vars_seq_blk = ;\n%let wcla_max_vars_seq_blk = ;\n%let wcla_ent_def_seq_blk = ;\n\n%create_clean_varname_blk_seq\n    (\n    ccvbs_seq_name = wcla_ent_def_seq_blk,\n    ccvbs_original_seq = &wcla_entity_definition_seq\n    );\n%create_clean_varname_blk_seq\n    (\n    ccvbs_seq_name = wcla_sum_vars_seq_blk,\n    ccvbs_original_seq = &wcla_sum_variables_seq\n    );\n%create_clean_varname_blk_seq\n    (\n    ccvbs_seq_name = wcla_avg_vars_seq_blk,\n    ccvbs_original_seq = &wcla_avg_variables_seq\n    );\n%create_clean_varname_blk_seq\n    (\n    ccvbs_seq_name = wcla_min_vars_seq_blk,\n    ccvbs_original_seq = &wcla_min_variables_seq\n    );\n%create_clean_varname_blk_seq\n    (\n    ccvbs_seq_name = wcla_max_vars_seq_blk,\n    ccvbs_original_seq = &wcla_max_variables_seq\n    );\n%let wcla_group_by_except_last = &wcla_ent_def_seq_blk _daft_year;\n%let wcla_group_by_last = _daft_&wcla_time_granularity;\n\n%let wcla_group_by = &wcla_group_by_except_last &wcla_group_by_last;\n\n%let wcla_location_count = %wordcnt(&wcla_entity_definition_seq, \" \");\n\n%if &debug_mode = 1 %then\n%do;\n    %put INFORMATION: Now processing &=wcla_sum_variables_seq;\n    %put INFORMATION: Now processing &=wcla_avg_variables_seq;\n    %put INFORMATION: Now processing &=wcla_min_variables_seq;\n    %put INFORMATION: Now processing &=wcla_max_variables_seq;\n    %put INFORMATION: Now processing &=wcla_avg_vars_seq_blk;\n    %put INFORMATION: Now processing &=wcla_sum_vars_seq_blk;\n    %put INFORMATION: Now processing &=wcla_min_vars_seq_blk;\n    %put INFORMATION: Now processing &=wcla_max_vars_seq_blk;\n    %put INFORMATION: Now processing &=wcla_entity_definition_seq;\n    %put INFORMATION: Now processing &=wcla_ent_def_seq_blk;\n    %put INFORMATION: Now processing &=wcla_group_by;\n%end;\n\n\n\ndata &wcla_temp_libname.._DAFT_RAW_DATA_ADJUSTED (keep =\n        &wcla_sum_vars_seq_blk\n        &wcla_avg_vars_seq_blk\n        &wcla_min_vars_seq_blk\n        &wcla_max_vars_seq_blk\n        &date_variable\n        &wcla_ent_def_seq_blk\n        );\n    set &wcla_input_ds ;\n    %do wcla_var_counter = 1 %to %wordcnt(&wcla_sum_vars_seq_blk, ' ');\n        %let wcla_variable_new = %scan(&wcla_sum_vars_seq_blk,\n                                        &wcla_var_counter,\n                                        ' ');\n        %let wcla_variable_old = %scan(&wcla_sum_variables_seq,\n                                        &wcla_var_counter,\n                                        \"#\");\n        &wcla_variable_new = &wcla_variable_old;\n    %end;\n    %do wcla_var_counter = 1 %to %wordcnt(&wcla_avg_vars_seq_blk, ' ');\n        %let wcla_variable_new = %scan(&wcla_avg_vars_seq_blk,\n                                        &wcla_var_counter,\n                                        ' ');\n        %let wcla_variable_old = %scan(&wcla_avg_variables_seq,\n                                        &wcla_var_counter,\n                                        \"#\");\n        &wcla_variable_new = &wcla_variable_old;\n    %end;\n    %do wcla_var_counter = 1 %to %wordcnt(&wcla_min_vars_seq_blk, ' ');\n        %let wcla_variable_new = %scan(&wcla_min_vars_seq_blk,\n                                        &wcla_var_counter,\n                                        ' ');\n        %let wcla_variable_old = %scan(&wcla_min_variables_seq,\n                                        &wcla_var_counter,\n                                        \"#\");\n        &wcla_variable_new = &wcla_variable_old;\n    %end;\n    %do wcla_var_counter = 1 %to %wordcnt(&wcla_max_vars_seq_blk, ' ');\n        %let wcla_variable_new = %scan(&wcla_max_vars_seq_blk,\n                                        &wcla_var_counter,\n                                        ' ');\n        %let wcla_variable_old = %scan(&wcla_max_variables_seq,\n                                        &wcla_var_counter,\n                                        \"#\");\n        &wcla_variable_new = &wcla_variable_old;\n    %end;\n    %do wcla_var_counter = 1 %to %wordcnt(&wcla_ent_def_seq_blk, ' ');\n        %let wcla_variable_new = %scan(&wcla_ent_def_seq_blk,\n                                        &wcla_var_counter,\n                                        ' ');\n        %let wcla_variable_old = %scan(&wcla_entity_definition_seq,\n                                        &wcla_var_counter,\n                                        \"#\");\n        &wcla_variable_new = &wcla_variable_old;\n    %end;\nrun;\n\n%let wcla_avg_vars_seq = %sysfunc(tranwrd(&wcla_avg_vars_seq_blk,\n                                            %str( ),\n                                            %str(#)\n                                            ));\n%let wcla_sum_vars_seq = %sysfunc(tranwrd(&wcla_sum_vars_seq_blk,\n                                            %str( ),\n                                            %str(#)\n                                            ));\n%let wcla_min_vars_seq = %sysfunc(tranwrd(&wcla_min_vars_seq_blk,\n                                            %str( ),\n                                            %str(#)\n                                            ));\n%let wcla_max_vars_seq = %sysfunc(tranwrd(&wcla_max_vars_seq_blk,\n                                            %str( ),\n                                            %str(#)\n                                            ));\n\n%create_cube_by_timeunit(\n    ccbt_input_ds = &wcla_temp_libname.._DAFT_RAW_DATA_ADJUSTED,\n    ccbt_output_ds =\n        &wcla_temp_libname.._DAFT_cube_base_clean_&wcla_time_granularity,\n    ccbt_debug_mode = &wcla_debug_mode,\n    ccbt_sum_variables_seq = &wcla_sum_vars_seq,\n    ccbt_avg_variables_seq = &wcla_avg_vars_seq,\n    ccbt_min_variables_seq = &wcla_min_vars_seq,\n    ccbt_max_variables_seq = &wcla_max_vars_seq,\n    ccbt_avg_variables_blk_seq = &wcla_avg_vars_seq_blk,\n    ccbt_sum_variables_blk_seq = &wcla_sum_vars_seq_blk,\n    ccbt_min_variables_blk_seq = &wcla_min_vars_seq_blk,\n    ccbt_max_variables_blk_seq = &wcla_max_vars_seq_blk,\n    ccbt_entity_definition_seq = &wcla_ent_def_seq_blk,\n    ccbt_date_variable = &wcla_date_variable,\n    ccbt_group_by = &wcla_group_by,\n    ccbt_time_granularity = &wcla_time_granularity,\n    ccbt_temp_libname = &wcla_temp_libname,\n    ccbt_agg_start_year = &wcla_agg_start_year,\n    ccbt_agg_end_year = &wcla_agg_end_year,\n    ccbt_keep_org_var_after_means = &wcla_keep_org_var_after_means\n\n    );\n/***\ndepending on the variables chosen by topic (sum, min or max), those\naggregated values are calculated by the group_by variables.\n***/\n\n%create_agg_by_period_by_lag(\n    cabpbl_input_ds =\n        &wcla_temp_libname.._DAFT_cube_base_clean_&wcla_time_granularity,\n    cabpbl_output_ds = &wcla_output_ds,\n    cabpbl_sum_vars_seq = &wcla_sum_variables_seq,\n    cabpbl_avg_vars_seq = &wcla_avg_variables_seq,\n    cabpbl_min_vars_seq = &wcla_min_variables_seq,\n    cabpbl_max_vars_seq = &wcla_max_variables_seq,\n    cabpbl_date_variable = &wcla_date_variable,\n    cabpbl_time_granularity = &wcla_time_granularity,\n    cabpbl_agg_period_seq = &wcla_agg_period_seq,\n    cabpbl_lag_period_seq = &wcla_lag_period_seq,\n    cabpbl_temp_libname = &wcla_temp_libname,\n    cabpbl_entity_definition_seq = &wcla_ent_def_seq_blk,\n    cabpbl_group_by = &wcla_group_by,\n    cabpbl_debug_mode = &wcla_debug_mode,\n    cabpbl_keep_org_var_after_means = &wcla_keep_org_var_after_means\n\n    );\n\n\n%mend wrapper_create_lagged_aggrgtns;\n\n%macro execute_all();\n\n%let directory_separator = /;\n%let write_log_into_file = &write_log_to_file_ui    ;\n%let provide_default_log_path = ;\n%let log_file_directory_source_ui = ;\n%if \"&log_file_path_ui\" ne \"\" %then\n%do;\n    %let provide_default_log_path = %scan(&log_file_path_ui, 2, \":\")/;\n    %let log_file_directory_source_ui = %scan(&log_file_path_ui, 1, \":\");\n%end;\n\n\n%let period_start_year = &period_start_year_ui;\n%let period_end_year = &period_end_year_ui;\n%let input_ds = &input_ds_ui;\n%let output_ds = &outputtable_ui;\n%let run_everything_in_CAS = &run_everything_in_CAS_ui;\n\n%let target_lib_output_ds = %scan(&output_ds, 1, '.');\n%let target_lib_engine = ; /* V9 or CAS */\nproc sql noprint;\n    select distinct(engine)\n    into :target_lib_engine\n    from dictionary.libnames\n    where upcase(libname) = \"%upcase(&target_lib_output_ds)\"\n    ;\nquit;\n%let run_environment = CAS;\n%let debug_mode = &debug_mode_ui;\n\n%let target_lib_engine = %upcase(%trim(%left(&target_lib_engine)));\n\n\n\n%let temp_libname = Public;\n%if &run_everything_in_CAS = 0 or\n    &target_lib_engine = V9 %then\n%do;\n    %let temp_libname = work;\n%end;\n\n%let sum_variables_seq = ;\n%do counter = 1 %to &sum_variables_seq_ui_count;\n    %let sum_variables_seq = &sum_variables_seq &&sum_variables_seq_ui_&counter._name.#;\n%end;\n\n%let avg_variables_seq = ;\n%do counter = 1 %to &avg_variables_seq_ui_count;\n    %let avg_variables_seq = &avg_variables_seq &&avg_variables_seq_ui_&counter._name.#;\n%end;\n\n%let min_variables_seq = ;\n%do counter = 1 %to &min_variables_seq_ui_count;\n    %let min_variables_seq = &min_variables_seq &&min_variables_seq_ui_&counter._name.#;\n%end;\n\n%let max_variables_seq = ;\n%do counter = 1 %to &max_variables_seq_ui_count;\n    %let max_variables_seq = &max_variables_seq &&max_variables_seq_ui_&counter._name.#;\n%end;\n\n%let entity_definition_seq = ;\n%do counter = 1 %to &entity_def_seq_ui_count;\n    %let entity_definition_seq = &entity_definition_seq &&entity_def_seq_ui_&counter._name.#;\n%end;\n\n%let date_variable = &date_variable_ui_1_name;\n%let time_granularity = &time_granularity_ui;\n%let agg_period_seq = &agg_period_seq_ui;\n%let lag_period_seq = &lag_period_seq_ui;\n%if &debug_mode = 1 %then\n%do;\n    %put INFORMATION: Now processing &=target_lib_engine;\n    %put INFORMATION: Now processing &=min_variables_seq;\n    %put INFORMATION: Now processing &=sum_variables_seq;\n    %put INFORMATION: Now processing &=avg_variables_seq;\n    %put INFORMATION: Now processing &=entity_definition_seq;\n    %put INFORMATION: Now processing &=max_variables_seq;\n%end;\n\n\n%if \"%upcase(&log_file_directory_source_ui)\" eq \"SASSERVER\" %then\n%do;\n    %let log_file_in_SAS_Content = 0;\n%end; %else\n%do;\n    %let log_file_in_SAS_Content = 1;\n%end;\n%let write_log_to_file = &write_log_to_file_ui;\n\n%if &write_log_to_file = 1 %then\n%do;\n\n    /**\n    determine and set todays date\n    **/\n    data _null_;\n        todaysdate = today();\n        year = year(todaysdate);\n        month = put(month(todaysdate), z2.);\n        day = put(day(todaysdate), z2.);\n        nowtime = time();\n        hour = put(hour(nowtime), z2.);\n        minute = put(minute(nowtime), z2.);\n        put minute;\n        timestamp = trim(left(year))||trim(left(month))||trim(left(day))||\"_\"||trim(left(hour))||trim(left(minute));\n        call symput('timestamp', timestamp);\n    run;\n    %let timestamp = %trim(%left(&timestamp));\n\n\n    %if &log_file_in_SAS_Content = 1 %then\n    %do;\n        filename logfile\n            filesrvc\n            folderpath = \"&provide_default_log_path\"\n            filename = \"wc_run_&timestamp.aggregations.log\";\n        filename printfl\n            filesrvc\n            folderpath = \"&provide_default_log_path\"\n            filename = \"wc_run_&timestamp.aggregations.out\";\n    %end; %else\n    %do;\n        filename logfile \"&provide_default_log_path.wc_run_&timestamp.aggregations.log\";\n        filename printfl \"&provide_default_log_path.wc_run_&timestamp.aggregations.out\";\n    %end;\n    proc printto\n        log=logfile new\n        print=printfl new;\n    quit;\n%end;\n\n\n\n%wrapper_create_lagged_aggrgtns(\n    wcla_input_ds = &input_ds,\n    wcla_output_ds = &output_ds,\n    wcla_run_environment = CAS,\n    wcla_debug_mode = &debug_mode,\n    wcla_sum_variables_seq = &sum_variables_seq,\n    wcla_avg_variables_seq = &avg_variables_seq,\n    wcla_min_variables_seq = &min_variables_seq,\n    wcla_max_variables_seq = &max_variables_seq,\n    wcla_entity_definition_seq = &entity_definition_seq,\n    wcla_date_variable = &date_variable,\n    wcla_time_granularity = &time_granularity,\n    wcla_agg_period_seq = &agg_period_seq,\n    wcla_lag_period_seq = &lag_period_seq,\n    wcla_directory_separator = &directory_separator,\n    wcla_temp_libname = &temp_libname,\n    wcla_agg_start_year = &period_start_year,\n    wcla_agg_end_year = &period_end_year\n    );\n\n\n%if &write_log_to_file = 1 %then\n%do;\n    proc printto ;\n    quit;\n%end;\n\n%mend execute_all;\n\n\n%execute_all();\n\n/**\nRestore original SAS options settings\n**/\n\n%adjust_option_setings_controlled(\n    aosc_running_mode = RESET\n    );\n\n%if &debug_mode_ui ne 1 %then\n%do;\n    proc datasets lib=work;\n        delete\n            _daft_:\n            _aosc:\n            ;\n    quit;\n%end;\n"}}